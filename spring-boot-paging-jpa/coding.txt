Vue键盘事件

<div id="app">
  <input type="text" @keydown="showInfo" />
</div>

<script>
Vue.config.keyCodes.huiche=98
new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!'
  },
	methods:{
		showInfo(e){
			console.log(e.key+","+e.keyCode)
			console.log(e.target.value)
		}
	}
})
</script>
================================================================================	

Vue 点击事件限制
<!--
	prevent:阻止默认事件（常用）
	stop:阻止事件冒泡（常用）
	once:事件只触发一次（常用）
-->
<div id="app">
  <div @click="show">
	  <a href="http://www.baidu.com" @click.stop.prevent="show">点击我</a>
	  </div>
</div>

<script>
	let num=0;
new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!'
  },
	methods:{
		show(){
			alert(num++);
		}
	}
})
</script>		
================================================================================	
React state属性

<script type="text/babel">
//1.创建组件
class Weather extends React.Component{
	//构造器调用几次？ ---1次
	constructor(props){
		super(props)
		//初始化状态
		this.state={isHot:true,wind:'微风'}
		//解决changeWeather中的this指向问题
		this.changeWeather=this.changeWeather.bind(this)
	}
	//render调用几次？ --- 1+n次 1是初始化的那次，n是状态更新的次数
	render(){
		//读取状态
		let {isHot,wind}=this.state
		return <h1 onClick={this.changeWeather}>今天的天气{isHot?'炎热':'寒冷'},{wind}</h1>
	}
	//changeWeather调用几次？ --- 点几次调几次
	changeWeather(){
		//changeWeather放在哪里？ --- Weather的原型对象上，供实例使用
		//由于changeWeather是作为onClick的回调，所有不是通过实例调用的，是直接调用
		//类中的方法默认开启了局部严格模式，所以changeWeather中的this为undefined
		let {isHot}=this.state
		//严重注意：状态必须通过setState进行更新，且更新是一种合并，不是替换
		this.setState({isHot:!isHot})
		//严重注意：状态(state)不可直接更改，下面这行就是直接更改！！！
		//this.state.isHot=!isHot //这是错误的写法
		console.log(this)
	}
}
//渲染组件到页面
ReactDOM.render(  
	<Weather/>,
	document.getElementById('example')
);
</script>

================================================================================	

React state简写
<script type="text/babel">
class Weather extends React.Component{
	state={'isHot':true,'wind':'微风'}
	render(){
		let {isHot,wind}=this.state
		return <h1 onClick={this.changeWeather}>今天的天气{isHot?'炎热':'寒冷'}，{wind}</h1>
	}
	//自定义给方法---要用赋值语句的形式+箭头函数
	changeWeather = ()=>{
		let {isHot}=this.state
		this.setState({'isHot':!isHot})
	}
}
ReactDOM.render(
	<Weather/>,
	document.getElementById('example')
);
</script>
================================================================================	

Ajax 标识变量,防止多次重复点击
const btns=document.querySelectorAll('button');
let x = null;
//标识变量
let isSending=false; //是否在发送AJAX请求
btns[0].onclick=function(){
	//判断标识变量
	if(isSending) x.absort(); // 如果正在发送，则取消该请求
	x=new XMLHttpRequest();
	//修改 标识变量的值
	isSending=true;
	x.open("GET","http://127.0.0.1:8080/delay");
	x.send();
	x.onreadystatechange = function(){
		if(x.readyState===4) {
			//修改标识变量
			isSending=false;
		}
	}
}
================================================================================

Vue 计算属性
    <div id="app">
        <p><input type="text" v-model="firstname" /><br />
            <input type="text" v-model="lastname"/></p>	
            {{fullname}}
    </div>
    <script>
 const vm=new Vue({
  el: '#app',
  data: {
	  firstname:'jack',
	  lastname:'lucy',
    message: 'Hello Vue.js!'
  },
	computed:{
		fullname:{
            //get有什么作用？当有人读取fullname时,get就会被调用，且返回值作为fullname的值
            //get什么时候调用？1.初次读取fullname时。2.所依赖的数据发生变化时
			get(){
				console.log("get被调用了")
				return this.firstname+"-"+this.lastname;
			},
            //set什么时候调用？当fullname被修改时
			set(value){
				console.log('set',value)
				const arr=value.split("-")
				this.firstname=arr[0]
				this.lastname=arr[1]
			}		
		}
	}
})
    </script>	
	
================================================================================	
Vue:计算属性简写
	computed:{
        //完整写法
		fullname(){
            console.log("get被调用了");
            return this.firstname+"-"+this.lastname
		}
	}
================================================================================	
React:实例化多个对象
<div id="example"></div>
<div id="example1"></div>
<div id="example2"></div>
<script type="text/babel">
class Person extends React.Component{
	render(){
		const {name,age,sex}=this.props	
		return <h1>{name}-{age}-{sex}</h1>
	}
}
ReactDOM.render(
	<Person name="jack" age="18" sex="男"/>,
	document.getElementById('example')
);
ReactDOM.render(
	<Person name="lucy" age="19" sex="女"/>,
	document.getElementById('example1')
);
ReactDOM.render(
	<Person name="mark" age="18" sex="男"/>,
	document.getElementById('example2')
);
</script>
================================================================================	
Ajax jquery get post 请求
    <div class="container">
        <button class="btn btn_primary">GET</button>
        <button class="btn btn_danger">POST</button>
        <button class="btn btn_info">通用型方法ajax</button>
    </div>
    <script>
        $("button").eq(0).click(function(){
            $.get("http://127.0.0.1:1666/",{a:100,b:200},function(data){
                console.log(data);
            },"json")
        })
        $("button").eq(1).click(function(){
            $.post("http://127.0.0.1:1666/",{a:100,b:200},function(data){
                console.log(data);
            },"json")
        })
       $("button").eq(2).click(function(){
            $.ajax({
                //url
                url:"http://127.0.0.1:1666/",
                //参数
                data:{a:100,b:200},
                //请求类型
                type:'GET',
                //响应体结果
                dataType:'json',
                //成功的回调
                success:function(data){
                    console.log(data);
                },
                //超时时间
                timeout:2000,
                //失败的回调
                error:function(){
                    console.log("出错啦！！");
                }
            })

        })		
    </script>
================================================================================	
Js 展开一个数组
let arr1=[1,3,5,7,9]
let arr2=[2,4,6,8,10]
console.log(...arr1) //展开一个数组
let arr3=[...arr1,...arr2] //连接数组

//在函数中使用
function sum(...numbers){
    return numbers.reduce((preValue,currentValue)=>{
        return preValue+currentValue
    })    
}
console.log(sum(1,2,3,4))

//构造字面量对象时，使用展开语法
let person={name:'tom',age:18}
let person2={...person}
//console.log(...person) 展开运算符，不能展开对象
person.name="jerry"
console.log(person2)
console.log(person)
================================================================================	
React 监视属性
<div id="app">
  <p>今天的天气{{info}}</p>
	<button @click="changeWeather">改变天气</button>
</div>

<script>
const vm=new Vue({
  el: '#app',
  data: {
    isHot:true
  },
	computed:{
		info(){
			return this.isHot?'炎热':'寒冷'
		}
	},
	methods:{
		changeWeather(){
			this.isHot=!this.isHot
		}
	}
})
vm.$watch('isHot',{
	immediate:true, //初始化时让handler调用一下
	//handler什么时候调用？当isHot发生改变时
	handler(newValue,oldValue){
		console.log('isHot被修改了',newValue,oldValue)
	}
})
</script>

================================================================================	
Ajax axios
    <script>
        let btn = document.querySelector("button")
        axios.defaults.baseURL="http://127.0.0.1:1666"
        btn.onclick=function(){
            axios.get('/',{
                params:{
                    id:100,
                    vip:7                    
                },             
            })
            .then(res => {
                console.log(res)
            })
            .catch(err => {
                console.error(err); 
            })
        }
        </script>
================================================================================	
React 属性限制
<div id="example"></div>
<div id="example1"></div>
<div id="example2"></div>
<script type="text/babel">
class Person extends React.Component{
	render(){
		const {name,age,sex}=this.props	
		return <h1>{name}-{age}-{sex}</h1>
	}
}
//对标签属性进行类型，必要性的限制
Person.propTypes={
	name: PropTypes.string.isRequired, //限制name必传，且为字符串
	sex: PropTypes.string,	//限制sex为字符串
	age: PropTypes.number,	//限制age为数值
	speak: PropTypes.func	//限制speak为函数
}
//指定默认标签属性值
Person.defaultProps={
	sex:'男',
	age:18
}
ReactDOM.render(
	<Person name="jack" />,
	document.getElementById('example')
);
ReactDOM.render(
	<Person name="lucy" age="19" sex="女"/>,
	document.getElementById('example1')
);
const p = {name:'老刘',age:18,sex:'女'}
ReactDOM.render(
	<Person {...p}/>,
	document.getElementById('example2')
);
</script>
================================================================================	
Vue中的watch默认不监测对象内部值的改变（一层）

配置deep:true可以监测对象内部值改变（多层）

Vue自身可以监测对象内部值的改变，但Vue提供的watch默认不可以

使用watch时根据数据的具体结构，决定是否采用深度监视

================================================================================	
<div id="app">
  <p>{{ message }}</p>
	<button @click="numbers.a++">add</button>{{numbers.a}}
</div>

<script>
new Vue({
  el: '#app',
  data: {
    message: 'Hello Vue.js!',
	  numbers:{
	  	a:1
	  }
  },
	watch:{
		//监视多级结构中某个属性的变化
		'numbers.a':{
			handler(){
				//console.log("a被改变了")
			}
		},
		//监视多级结构中所有属性的变化
		numbers:{
			deep:true,
			handler(){
				console.log("numbers被改变了")
			}
		}
	}
})
</script>
================================================================================	

Sql：查询条件拼接

SELECT CONCAT(NAME,email) AS '信息' FROM `customers`
================================================================================	
#格式化输出
#scrapy框架的时候 excel文件 mysql redis
name = '红浪漫晶哥'
age=18
# %s代表的是字符串 %d代表的是数值
print("大家好，我叫%s，今年%d"%(name,age))
================================================================================	

SpringMVC支持ant风格的路径

?：表示任意的单个字符

*：表示任意的0个或多个字符

**：表示任意的一层或多层目录

注意：在使用**时，只能使用/**/xxx的方式

================================================================================	
HashSet添加元素的过程
我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值
此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置）
判断数组此位置上是否已有元素
	如果此位置上没有其他元素，则元素a添加成功。---->情况1
	如果此位置上有其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值
		如果hash值不相同，则元素a添加成功 ---->情况2
		如果hash值相同，进而需要调用元素a所在类的equals()方法
			equals()返回true，元素a添加失败
			equals()返回false，则元素a添加成功。 ---->情况3

对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上的数据以链表的方式存储
jdk 7 ：元素a放到数组中，指向原来的元素
jdk 8 ：原来的元素在数组中，指向元素a
总结：七上八下

HashSet底层：数组+链表的结构

================================================================================	
        //执行，并返回结果集
        ResultSet result = ps.executeQuery();
        //处理结果集，next判断是否有下一条数据，如果有则移动指针
        if(result.next()){
            //获取当前这条数据的各个字段值
            int id = result.getInt(1);
            String name = result.getString(2);
            String email = result.getString(3);
            java.sql.Date birth = result.getDate(4);
            //方式三：将数据封装成一个对象（推荐）
            Customer customer = new Customer(id, name, email, birth);
            //5.资源的关闭
            System.out.println(customer);
        }
================================================================================	

如果该列的值为null
SELECT IFNULL(photo,0) AS '信息' FROM `customers`
================================================================================	
<div id="app">
  <p @click="changeWeather">{{ message }}{{isHot?'炎热':'寒冷'}}</p>
</div>

<script>
const vm=new Vue({
  el: '#app',
  data: {
    message: '今天天气',
	  isHot:true
  },
	methods:{
		changeWeather(){
			this.isHot=!this.isHot
		}
	},
	watch:{
		//正常写法
		isHot:{
			handler(newValue,oldValue){
				//console.log('isHot被修改了：',newValue,oldValue)
			}
		},
		//简写		
		isHot(newValue,oldValue){
			//console.log('isHot被修改了：',newValue,oldValue)
		}
	}
})
//正常写法
vm.$watch('isHot',{
	handler(newValue,oldValue){
		//console.log('isHot被修改了：',newValue,oldValue)
	}
})
vm.$watch('isHot',function(newValue,oldValue){
	console.log('isHot被修改了：',newValue,oldValue)
})
</script>
================================================================================	

ServletContext是一个接口，它表示Servlet上下文对象

一个web工程，只有一个ServletContext对象实例

ServletContext是web工程部署启动的时候创建，在web工程停止的时候销毁

ServletContext是一个域对象，域对像可以像Map一样存取数据，存数据：setAttribute，取数据：getAttribute，删除数据：removeAttribute
================================================================================	
向Set中添加的数据，其所在的类一定要重写hashCode()和equals()

重写的hashCode()和equals()尽可能保持一致：相等的对象必须具有相等的散列码
================================================================================

computed和watch之间的区别

1.computd能完成的功能，watch都可以完成
2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作

两个重要的小原则
1.所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象
2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数，Promise的回调函数），最好写成箭头函数
   这样this的指向才是vm 或 组件实例对象	
================================================================================	
<div id="app">
	姓：<input type="text" v-model="firstname" /><br />
	名：<input type="text" v-model="lastname" /><br />
	{{fullname}}
</div>

<script>
new Vue({
  el: '#app',
  data: {
    firstname:'张',
	 lastname:'三',
	  fullname:'张-三'
  },
	watch:{
		firstname(val){
			setTimeout(()=>{
				this.fullname= val+'-'+this.lastname	
			},1000)

		},
		lastname(val){
			this.fullname= this.firstname+'-'+val
		}
	}
})
</script>
================================================================================	

   public Customer mysql_con(String sql,Object ...args) throws Exception{
        Connection conn = getConnection();
        PreparedStatement ps = conn.prepareStatement(sql);
        for(int i = 0; i < args.length; i++){
            ps.setObject(i+1,args[i]);
        }
		//执行，获取结果集
        ResultSet rs = ps.executeQuery();
        //获取结果集的元数据：ResultSetMetaData
        ResultSetMetaData rsmd = rs.getMetaData();
        //通过ResultSetMetaData获取结果集中的列数
        int count = rsmd.getColumnCount();
        if(rs.next()){
            Customer cust = new Customer();
            //处理结果集一行数据中的每一列
            for (int i = 0; i < count; i++) {
                //获取列值：通过ResultSet
                Object columnValue = rs.getObject(i + 1);

                //获取每个列的列名:通过ResultSetMetaData
                String columnName = rsmd.getColumnName(i + 1);

                //给cust对象指定的columnName属性，赋值为columnValue：通过反射
                Field field = Customer.class.getDeclaredField(columnName);
                field.setAccessible(true);
                field.set(cust,columnValue);
            }
            return cust;
        }
        rs.close();
        closeResource(conn,ps);
        return null;
    }
================================================================================	
<div id="example"></div>
<script type="text/babel">
function Person(props){
	const {name,age,sex}=props
	return (
		<ul>
			<li>姓名：{name}</li>
			<li>性别：{sex}</li>
			<li>年龄：{age}</li>
		</ul>
	)
}
Person.propTypes={
	name:PropTypes.string.isRequired,
	sex:PropTypes.string,
	age:PropTypes.number
}
Person.defaultProps={
	sex:'男',
	age:18
}
ReactDOM.render(
	<Person name='jerry'/>,
	document.getElementById('example')
);
</script>	

================================================================================	

返回一个文件
response.send(__dirname+'/index.html')	
================================================================================		

    <div id="app">
        <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
      <p :class="mood" @click="changeMood">{{ message }}</p>
        <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
      <p :class="classAttr">{{message}}</p>
      <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 -->
      <p :class="classObj">{{message}}</p>
    </div>
    
    <script>
    const vm=new Vue({
      el: '#app',
      data: {
        message: 'Hello Vue.js!',
          mood:'normal',
          classAttr:['atguigu1','atguigu2','atguigu3'],
          classObj:{
              atguigu1:false,
              atguigu2:false,
          }
      },
        methods:{
            changeMood(){
                const arr=['happy','sad','normal']
                const index=Math.floor(Math.random()*3)
                this.mood=arr[index]
            }
        }
    })
    </script>	
================================================================================	
#input返回的是字符串类型
age=input("请输入你的年龄：")

#字符串和整数int是不可以比较的
if int(age)>18:
    print("你可以去网吧了")

#案例中考察了三个知识点
#（1）控制台输入
#（2）强制类型转换
#（3）int和str是不能比较的	
================================================================================

    <div></div>
    <script>
        function handle(data){
            const div=document.querySelector('div');
            div.innerHTML=data.name
        }
    </script>
	//script属于get请求
    <script src="http://127.0.0.1:1666/"></script>

app.all("/",(request,response)=>{
    //设置响应头 允许跨域
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Headers","*")
    //设置响应
    const data={
        name:'atguigu'
    }
    let str=JSON.stringify(data)
	//函数在客户端已经定义好
        response.send(`handle(${str})`);
});	
================================================================================		
package domain;
import java.util.*;
public class HelloWorld {

    public static void main(String[] args) {
        TreeSet set = new TreeSet();
        set.add(new User("jack",18));
        set.add(new User("mark",19));
        set.add(new User("tony",21));
        set.add(new User("pony",16));
        set.add(new User("lucy",18));
        set.add(new User("jerry",17));
        Iterator iterator = set.iterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }

}
class User implements Comparable{
    private String name;
    private int age;
    public User(){

    }
    public User(String name,int age){
        this.name=name;
        this.age=age;
    }
    public String getName(){
        return this.name;
    }
    public void setName(String name){
        this.name=name;
    }
    public int getAge(){
        return this.age;
    } 
    public void setAge(int age){
        this.age=age;
    }
    @Override
    public String toString(){
        return this.name+","+this.age;
    }
    @Override
    public int compareTo(Object o){
        if(o instanceof User){
            User user=(User)o;
            int compare=this.name.compareTo(user.name);
            if(compare!=0){
                return compare;
            }else{
                return Integer.compare(this.age,user.age);
            }
        }else{
            System.out.println("输入的类型不匹配");
        }
        return 0;
    }
}
============================================================
import React from 'react';
import './style.css';

export default class Demo extends React.Component {
  //展示左侧输入框的数据
  showData = () => {
    const { input1 } = this.refs;
    alert(input1.value);
  };
  //展示右侧输入框的数据
  showData2 = () => {
    const { input2 } = this.refs;
    alert(input2.value);
  };
  render() {
    return (
      <div>
        <input ref="input1" type="text" placeholder="点击按钮提交数据" />
        &nbsp;
        <button onClick={this.showData}>点击我提示左侧的数据</button>&nbsp;
        <input
          ref="input2"
          onB	lur={this.showData2}
          type="text"
          placeholder="失去焦点提交数据"
        />
      </div>
    );
  }
}

============================================================
appDiv.style.border="solid 1px #f00"
//1.创建script标签
const script=document.createElement('script');
//2.设置标签的src属性
script.src="http://www.baidu.com";
//3.将script插入到文档中
document.body.appendChild(script);
============================================================
绑定样式：
    1.class样式
        写法:class="xxx",xxx可以是字符串，对象，数组。
        字符串写法适用于：类名不确定，要动态获取。
        对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
        数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
    2.style样式
        :style="{fontSize:xxx}"其中xxx是动态值。
        :style="[a,b]"其中a,b是样式对象。

============================================================

Entry：Webpack 以那个文件作为入口文件，开始打包

Output：告诉Webpack打包后的资源bundles，输出到哪里去，以及如何命名

Loader：让Webpack能够去处理那些非JavaScript文件（webpack自身只能理解JavaScript）

Plugins：可以用来打包优化和压缩，重新定义环境变量
============================================================
条件渲染：
    1.v-if
        写法：
            (1).v-if="表达式"
            (2).v-else-if="表达式"
            (3).v-else="表达式"
       适用于：切换频率较低的场景
       特点：不展示的DOM元素直接被移除。
       注意：v-if可以和:v-else-if,v-else一起使用,但要求结构不能被“打断”。
    2.v-show
        写法：v-show="表达式"
        适用于：切换频率较高的场景。
        特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
    3.备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到。       
============================================================
环境变量：
    当我们在命令行窗口打开一个文件，或调用一个程序时，
        系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
        如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
        如果没有找到则报错
    所以我们可以将一些经常需要访问的程序和文件的路径添加到path中
        这样我们就可以在任意位置来访问这些文件和程序了
============================================================
@RequestParam是将请求参数和控制器方法的形参创建映射关系
@RequestParam一共有三个属性：
value:指定为形参赋值的请求参数的参数名
required:设置是否必须传输此请求参数，默认值为true
defaultValue:不管required属性值为true或false,当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值
@RequestParam(value="user_name",required=false,defalutValue="hehe")
============================================================
每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中。
然后传递到service方法（doGet和doPost）中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的
信息。
============================================================
#应用场景 会爬取一个列表返回给我们
#循环一个列表
a_list=['周杰伦','林俊杰','王力宏'];

#遍历列表中的元素
for i in a_list:
	print(i)

#判断列表中的元素的个数	
print(len(a_list))	

for i in range(len(a_list)):
	print(i)
============================================================
HttpServletRequest类的常用方法
	getRequestURI() 获取请求的资源路径
	getRequestURL() 获取请求的统一资源定位符（绝对路径）
	gerRemoteHost()	获取客户端的ip地址
	getHeader()		获取请求头
	getParameter()	获取请求参数
	getParameterValues()	获取请求的参数（多个值的时候使用）
	getMethod()		获取请求的方式GET 或 POST
	getAttribute(key)		获取域数据
	getRequestDispatcher()	获取请求转发对象
============================================================
项目描述
1）此项目为一个前后台分离的后台管理的SPA，包括前端PC应用和后端应用
2）包括用户管理/商品分类管理/商品管理/权限管理等功能模块
3）前端：使用React全家桶+Antd+Axios+ES6+Webpack等技术
4）后端：使用Node+Express+Mongdb等技术
5）采用模块化、组件化、工程化的模式开发
============================================================
  <div id="app">
    <!-- 遍历数组 -->
    <h2>人员信息</h2>
    <ul>
      <li v-for="(p,index) in persons" :key="index">
        {{p.name}}-{{p.age}}
      </li>
    </ul>
    <!--遍历对象-->
    <h2>汽车信息</h2>
    <ul>
      <li v-for="(value,k) of car" :key="k">
        {{k}}-{{value}}
      </li>
    </ul>
    <!--遍历字符串-->
    <h2>字符信息</h2>
    <ul>
      <li v-for="(char,index) of str" :key="index">
        {{char}}-{{index}}
      </li>
    </ul>
    <!--遍历指定次数-->
    <ul>
      .<li v-for="(number,index) of 5" :key="index">
        {{number}}-{{index}}
      </li>
    </ul>
  </div>
  
  <script>
  new Vue({
    el: '#app',
    data: {
      persons: [
        {name:'zhangsan',age:19},
        {name:'lisi',age:18},
        {name:'wang',age:20}        
      ],
      car:{
        name:'奥迪A8',
        price:'70万',
        color:'黑色'
      },
      str:'hello'
    }
  })
  </script> 
============================================================
v-for指令：
	1.用于展示列表数据
	2.语法：v-for="(item, index) in xxx" :key="yyy"
	3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）
============================================================
.pink{
    width:66px;
    height:66px;
    background:green;
    float:left;
    margin-right:16px;
}
<div class="pink"></div>
<div class="pink"></div>
<div class="pink"></div>
window.onload=function(){
    var element=document.querySelectorAll(".pink")
    for(let i = 0;i<element.length;i++){
        element[i].onclick=function(){
            element[i].style.background="pink"
        }
    }
}
============================================================

安装json-server

npm install -g json-server

db.json
posts代表文章 comments代表评论 profile代表个人
postId关联文章id author关联name
{
 "posts":[
	{"id":1,"title":"json-server","author":"typicode"}
	 ],
  "comments":[
	{"id":1,"body":"some comment","postId":1}
	],
  "profile":{"name":"typicode"}
}

启动json-server

json-server --watch db.json

============================================================
============================================================
============================================================
============================================================
============================================================
============================================================
============================================================
