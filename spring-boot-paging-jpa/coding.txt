

Js 展开一个数组
let arr1=[1,3,5,7,9]
let arr2=[2,4,6,8,10]
console.log(...arr1) //展开一个数组
let arr3=[...arr1,...arr2] //连接数组

//在函数中使用
function sum(...numbers){
    return numbers.reduce((preValue,currentValue)=>{
        return preValue+currentValue
    })    
}
console.log(sum(1,2,3,4))

//构造字面量对象时，使用展开语法
let person={name:'tom',age:18}
let person2={...person}
//console.log(...person) 展开运算符，不能展开对象
person.name="jerry"
console.log(person2)
console.log(person)

================================================================================	


================================================================================	

Sql：查询条件拼接

SELECT CONCAT(NAME,email) AS '信息' FROM `customers`
================================================================================	
#格式化输出
#scrapy框架的时候 excel文件 mysql redis
name = '红浪漫晶哥'
age=18
# %s代表的是字符串 %d代表的是数值
print("大家好，我叫%s，今年%d"%(name,age))
================================================================================	

SpringMVC支持ant风格的路径

?：表示任意的单个字符

*：表示任意的0个或多个字符

**：表示任意的一层或多层目录

注意：在使用**时，只能使用/**/xxx的方式

================================================================================	
HashSet添加元素的过程
我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值
此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置）
判断数组此位置上是否已有元素
	如果此位置上没有其他元素，则元素a添加成功。---->情况1
	如果此位置上有其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值
		如果hash值不相同，则元素a添加成功 ---->情况2
		如果hash值相同，进而需要调用元素a所在类的equals()方法
			equals()返回true，元素a添加失败
			equals()返回false，则元素a添加成功。 ---->情况3

对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上的数据以链表的方式存储
jdk 7 ：元素a放到数组中，指向原来的元素
jdk 8 ：原来的元素在数组中，指向元素a
总结：七上八下

HashSet底层：数组+链表的结构

================================================================================	
        //执行，并返回结果集
        ResultSet result = ps.executeQuery();
        //处理结果集，next判断是否有下一条数据，如果有则移动指针
        if(result.next()){
            //获取当前这条数据的各个字段值
            int id = result.getInt(1);
            String name = result.getString(2);
            String email = result.getString(3);
            java.sql.Date birth = result.getDate(4);
            //方式三：将数据封装成一个对象（推荐）
            Customer customer = new Customer(id, name, email, birth);
            //5.资源的关闭
            System.out.println(customer);
        }
================================================================================	

如果该列的值为null
SELECT IFNULL(photo,0) AS '信息' FROM `customers`

================================================================================	

ServletContext是一个接口，它表示Servlet上下文对象

一个web工程，只有一个ServletContext对象实例

ServletContext是web工程部署启动的时候创建，在web工程停止的时候销毁

ServletContext是一个域对象，域对像可以像Map一样存取数据，存数据：setAttribute，取数据：getAttribute，删除数据：removeAttribute
================================================================================	
向Set中添加的数据，其所在的类一定要重写hashCode()和equals()

重写的hashCode()和equals()尽可能保持一致：相等的对象必须具有相等的散列码
================================================================================

computed和watch之间的区别

1.computd能完成的功能，watch都可以完成
2.watch能完成的功能，computed不一定能完成，例如：watch可以进行异步操作

两个重要的小原则
1.所有被Vue管理的函数，最好写成普通函数，这样this的指向才是vm 或 组件实例对象
2.所有不被Vue所管理的函数（定时器的回调函数、ajax的回调函数，Promise的回调函数），最好写成箭头函数
   这样this的指向才是vm 或 组件实例对象	
================================================================================	

   public Customer mysql_con(String sql,Object ...args) throws Exception{
        Connection conn = getConnection();
        PreparedStatement ps = conn.prepareStatement(sql);
        for(int i = 0; i < args.length; i++){
            ps.setObject(i+1,args[i]);
        }
		//执行，获取结果集
        ResultSet rs = ps.executeQuery();
        //获取结果集的元数据：ResultSetMetaData
        ResultSetMetaData rsmd = rs.getMetaData();
        //通过ResultSetMetaData获取结果集中的列数
        int count = rsmd.getColumnCount();
        if(rs.next()){
            Customer cust = new Customer();
            //处理结果集一行数据中的每一列
            for (int i = 0; i < count; i++) {
                //获取列值：通过ResultSet
                Object columnValue = rs.getObject(i + 1);

                //获取每个列的列名:通过ResultSetMetaData
                String columnName = rsmd.getColumnName(i + 1);

                //给cust对象指定的columnName属性，赋值为columnValue：通过反射
                Field field = Customer.class.getDeclaredField(columnName);
                field.setAccessible(true);
                field.set(cust,columnValue);
            }
            return cust;
        }
        rs.close();
        closeResource(conn,ps);
        return null;
    }
================================================================================	
<div id="example"></div>
<script type="text/babel">
function Person(props){
	const {name,age,sex}=props
	return (
		<ul>
			<li>姓名：{name}</li>
			<li>性别：{sex}</li>
			<li>年龄：{age}</li>
		</ul>
	)
}
Person.propTypes={
	name:PropTypes.string.isRequired,
	sex:PropTypes.string,
	age:PropTypes.number
}
Person.defaultProps={
	sex:'男',
	age:18
}
ReactDOM.render(
	<Person name='jerry'/>,
	document.getElementById('example')
);
</script>	

================================================================================	

返回一个文件
response.send(__dirname+'/index.html')	
================================================================================		

    <div id="app">
        <!-- 绑定class样式--字符串写法，适用于：样式的类名不确定，需要动态指定 -->
      <p :class="mood" @click="changeMood">{{ message }}</p>
        <!-- 绑定class样式--数组写法，适用于：要绑定的样式个数不确定、名字也不确定 -->
      <p :class="classAttr">{{message}}</p>
      <!-- 绑定class样式--对象写法，适用于：要绑定的样式个数确定，名字也确定，但要动态决定用不用 -->
      <p :class="classObj">{{message}}</p>
    </div>
    
    <script>
    const vm=new Vue({
      el: '#app',
      data: {
        message: 'Hello Vue.js!',
          mood:'normal',
          classAttr:['atguigu1','atguigu2','atguigu3'],
          classObj:{
              atguigu1:false,
              atguigu2:false,
          }
      },
        methods:{
            changeMood(){
                const arr=['happy','sad','normal']
                const index=Math.floor(Math.random()*3)
                this.mood=arr[index]
            }
        }
    })
    </script>	
================================================================================	
#input返回的是字符串类型
age=input("请输入你的年龄：")

#字符串和整数int是不可以比较的
if int(age)>18:
    print("你可以去网吧了")

#案例中考察了三个知识点
#（1）控制台输入
#（2）强制类型转换
#（3）int和str是不能比较的	
================================================================================

    <div></div>
    <script>
        function handle(data){
            const div=document.querySelector('div');
            div.innerHTML=data.name
        }
    </script>
	//script属于get请求
    <script src="http://127.0.0.1:1666/"></script>

app.all("/",(request,response)=>{
    //设置响应头 允许跨域
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Headers","*")
    //设置响应
    const data={
        name:'atguigu'
    }
    let str=JSON.stringify(data)
	//函数在客户端已经定义好
        response.send(`handle(${str})`);
});	
============================================================

============================================================
appDiv.style.border="solid 1px #f00"
//1.创建script标签
const script=document.createElement('script');
//2.设置标签的src属性
script.src="http://www.baidu.com";
//3.将script插入到文档中
document.body.appendChild(script);
============================================================
绑定样式：
    1.class样式
        写法:class="xxx",xxx可以是字符串，对象，数组。
        字符串写法适用于：类名不确定，要动态获取。
        对象写法适用于：要绑定多个样式，个数不确定，名字也不确定。
        数组写法适用于：要绑定多个样式，个数确定，名字也确定，但不确定用不用。
    2.style样式
        :style="{fontSize:xxx}"其中xxx是动态值。
        :style="[a,b]"其中a,b是样式对象。

============================================================

Entry：Webpack 以那个文件作为入口文件，开始打包

Output：告诉Webpack打包后的资源bundles，输出到哪里去，以及如何命名

Loader：让Webpack能够去处理那些非JavaScript文件（webpack自身只能理解JavaScript）

Plugins：可以用来打包优化和压缩，重新定义环境变量
============================================================
条件渲染：
    1.v-if
        写法：
            (1).v-if="表达式"
            (2).v-else-if="表达式"
            (3).v-else="表达式"
       适用于：切换频率较低的场景
       特点：不展示的DOM元素直接被移除。
       注意：v-if可以和:v-else-if,v-else一起使用,但要求结构不能被“打断”。
    2.v-show
        写法：v-show="表达式"
        适用于：切换频率较高的场景。
        特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
    3.备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到。       
============================================================
环境变量：
    当我们在命令行窗口打开一个文件，或调用一个程序时，
        系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
        如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
        如果没有找到则报错
    所以我们可以将一些经常需要访问的程序和文件的路径添加到path中
        这样我们就可以在任意位置来访问这些文件和程序了
============================================================
@RequestParam是将请求参数和控制器方法的形参创建映射关系
@RequestParam一共有三个属性：
value:指定为形参赋值的请求参数的参数名
required:设置是否必须传输此请求参数，默认值为true
defaultValue:不管required属性值为true或false,当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值
@RequestParam(value="user_name",required=false,defalutValue="hehe")
============================================================
每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中。
然后传递到service方法（doGet和doPost）中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的
信息。
============================================================
#应用场景 会爬取一个列表返回给我们
#循环一个列表
a_list=['周杰伦','林俊杰','王力宏'];

#遍历列表中的元素
for i in a_list:
	print(i)

#判断列表中的元素的个数	
print(len(a_list))	

for i in range(len(a_list)):
	print(i)
============================================================
HttpServletRequest类的常用方法
	getRequestURI() 获取请求的资源路径
	getRequestURL() 获取请求的统一资源定位符（绝对路径）
	gerRemoteHost()	获取客户端的ip地址
	getHeader()		获取请求头
	getParameter()	获取请求参数
	getParameterValues()	获取请求的参数（多个值的时候使用）
	getMethod()		获取请求的方式GET 或 POST
	getAttribute(key)		获取域数据
	getRequestDispatcher()	获取请求转发对象
============================================================
项目描述
1）此项目为一个前后台分离的后台管理的SPA，包括前端PC应用和后端应用
2）包括用户管理/商品分类管理/商品管理/权限管理等功能模块
3）前端：使用React全家桶+Antd+Axios+ES6+Webpack等技术
4）后端：使用Node+Express+Mongdb等技术
5）采用模块化、组件化、工程化的模式开发

============================================================
v-for指令：
	1.用于展示列表数据
	2.语法：v-for="(item, index) in xxx" :key="yyy"
	3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）
============================================================
.pink{
    width:66px;
    height:66px;
    background:green;
    float:left;
    margin-right:16px;
}
<div class="pink"></div>
<div class="pink"></div>
<div class="pink"></div>
window.onload=function(){
    var element=document.querySelectorAll(".pink")
    for(let i = 0;i<element.length;i++){
        element[i].onclick=function(){
            element[i].style.background="pink"
        }
    }
}
============================================================

安装json-server

npm install -g json-server

db.json
posts代表文章 comments代表评论 profile代表个人
postId关联文章id author关联name
{
 "posts":[
	{"id":1,"title":"json-server","author":"typicode"}
	 ],
  "comments":[
	{"id":1,"body":"some comment","postId":1}
	],
  "profile":{"name":"typicode"}
}

启动json-server

json-server --watch db.json

============================================================
添加元素的几个方法：

append 在末尾添加元素

insert 在指定位置插入元素

extend 合并两个列表
============================================================
//1. 一定要初始化
//const A;
//2. 一般常量使用大写（潜规则）
//const a = 100;
//3. 常量的值不能修改
//4. 块儿级作用域
{
  const PLAYER = 'UZI'
}
//5. 对于数组和对象的元素修改，不算做对常量的修改，不会报错
const TEAM=['UZI','MXLG',"Ning","Letme"];
TEAM.push('Meiko')
console.log(TEAM)
============================================================

npm init 取名 webpack-test

全局安装：npm i webpack webpack-cli -g

本地安装：npm i webpack webpack-cli -D

index.js: webpack入口起点文件

1. 运行指令
	开发环境：webpack ./src/index.js -o ./build/built.js --mode=development
	webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js
	整体打包环境，是开发环境
	生产环境：webpack ./src/index.js -o ./build/built.js --mode=production
	webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js
	整体打包环境，是生产环境
2. 结论：
	1. webpack能处理js/json资源，不能处理css/img等其他资源
	2. 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~
	3. 生产环境比开发环境多一个压缩js代码

import data from './data.json'
console.log(data)           
============================================================

SELECT * FROM `user` WHERE NAME = '1' OR ' and password = '=1 OR '1' = '1'
============================================================

    <script src="https://cdn.bootcdn.net/ajax/libs/axios/0.9.1/axios.js"></script>
    <button onclick="testGet()">get</button>
    <button onclick="testPost()">post</button>
    <script>
        function testGet() {
            axios.get("http://localhost:3000/posts/1")
            .then(response=>{
                console.log("/posts get", response.data)
            })
        }
        function testPost(){
	        axios.post("http://localhost:3000/posts",{"title":"json-server3","author":"typicode3"})
	        .then(response=>{
		    console.log('/posts post', response.data)
	    })
}
    </script>
============================================================
面试题：react、vue中的key有什么作用？(key的内部原理)

1. 虚拟DOM中的key的作用：
	key是由虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】
	随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2.对比规则：
	(1). 旧虚拟DOM中找到了与新虚拟DOM相同的key：
		若虚拟DOM中的内容没变，直接使用之前的真实DOM!
		若虚拟DOM中的内容变了，则生成新的真实DOM，然后替换掉页面中之前的真实DOM。

	(2). 旧虚拟DOM中未找到与新虚拟DOM相同的key
		创建新的真实DOM，随后渲染到页面

3. 用index作为key可能会引发的问题：
	1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作：
			会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。

	2. 如果结构中还包括输入类的DOM：
			会产生错误DOM更新 ==> 界面有问题。

4. 开发中如何选择key?：
	1. 最好使用每条数据的唯一的标识作为key，比如id、手机号、身份证号、学号等唯一值。
	2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
		使用index作为key是没有问题的。
============================================================
关键字 in

含义：判断某字段的值是否属于in列表中某一项
特点：
	使用in提高语句简洁度
	in列表的值类型必须一致或兼容
============================================================
除了解决Statement的拼串、sql问题之外，PreparedStatement还有哪些好处呢？
1. PreparedStatement可以操作Blob的数据，而Statement做不到
2. PreparedStatement可以实现更高效率的批量操作
============================================================
获取长度：len

查找内容：find 如果存在，则返回改内容在字符串中的第一次出现的索引值，否则返回-1

判断：startswith，endswith 判断字符串以谁开头、结尾

计算出现次数：count 

替换内容：replace 

切割字符串：split

修改大小写：upper，lower

空格处理：strip
============================================================
    <div id="example"></div>
    <script type="text/babel">
        class Demo extends React.Component{
            //React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点，该容器时“专人专用”的
            myRef1=React.createRef()
            myRef2=React.createRef()
            showInfo=()=>{
                alert(this.myRef1.current.value);
            }
            showData=()=>{
                alert(this.myRef2.current.value);
            }
            render(){
                return(
                    <div>
                        <input ref={this.myRef1} type='text' placeholder='请输入数据'/>
                        <button onClick={this.showInfo}>点击显示数据</button>
                        <input onBlur={this.showData} ref={this.myRef2} type='text' placeholder='失去焦点显示数据'/>
                        </div>
                )
            }
        }
    ReactDOM.render(<Demo/>,document.getElementById('example'))
    </script>
============================================================
ps.execute()
如果执行的是查询操作，有返回结果，则此方法返回true
如果执行的是增、删、改操作，没有返回结果，则此方法返回false
============================================================
git 常用基本命令

git config --global user.name "username" //配置用户名

git config --global user.email "xx@gmail.com" //配置邮箱

git init //初始化生成一个本地仓库

git add //添加到暂存区

git commit -m "message" //提交到本地仓库

git remote add origin url //关联到远程仓库
============================================================

Vue:计算属性实现搜索功能 //#region //#endregion
  <div id="app">
    <input v-model='keyword' type='text' placeholder='请输入您想查找的人'>
    <ul v-for="p in fillPerson">
      {{p.id}}-{{p.name}}-{{p.age}}-{{p.sex}}
    </ul>
  </div>
  
  <script>
  //计算属性实现搜索功能
  const vm=new Vue({
    el: '#app',
    data: {
      persons:[
        {id:'001',name:'马冬梅',age:'45',sex:'女'},
        {id:'002',name:'周冬雨',age:'34',sex:'女'},
        {id:'003',name:'周杰伦',age:'45',sex:'男'},
        {id:'004',name:'温兆伦',age:'61',sex:'男'},
      ],
      keyword:'',
      fillPerson:[]  	  
    },
    watch:{
      #keyword:{
        immediate:true,
        handler(val){
          this.fillPerson=#this.persons.filter((p)=>{
            return p.name.#indexOf(val) !== -1
          })
        }
      }
    },	
    computed:{
      fillPerson(){
          return this.persons.filter((p)=>{
              return p.name.indexOf(this.keyword)!==-1
          })
      }
    }
  })

  </script>
============================================================
1. 通过onXxx属性指定事件处理函数（注意大小写）
	a. React使用的是自定义（合成）事件，而不是使用的原生DOM事件 ---为了更好的兼容性
	b. React中的事件是通过事件委托方式处理的（委托给组件最外层的元素） ---为了更高效
2. 通过event.target得到发生时间的DOM元素对象 --- 不要过度使用ref
============================================================

//1. 数组的解构
const F4=['小沈阳','刘能','赵四','宋小宝']
let [xiao,liu,zhao,song]=F4
console.log(xiao)

//2. 对象的解构
const zhao={
    name:'赵本山',
    age:68,
    xiaopin:function(){
        console.log("我可以演小品")
    }
}
let {xiaopin}=zhao
xiaopin()


============================================================
