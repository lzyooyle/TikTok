

Js 展开一个数组
let arr1=[1,3,5,7,9]
let arr2=[2,4,6,8,10]
console.log(...arr1) //展开一个数组
let arr3=[...arr1,...arr2] //连接数组

//在函数中使用
function sum(...numbers){
    return numbers.reduce((preValue,currentValue)=>{
        return preValue+currentValue
    })    
}
console.log(sum(1,2,3,4))

//构造字面量对象时，使用展开语法
let person={name:'tom',age:18}
let person2={...person}
//console.log(...person) 展开运算符，不能展开对象
person.name="jerry"
console.log(person2)
console.log(person)



================================================================================	
HashSet添加元素的过程
我们向HashSet中添加元素a，首先调用元素a所在类的hashCode()方法，计算元素a的哈希值
此哈希值接着通过某种算法计算出在HashSet底层数组中的存放位置（即为：索引位置）
判断数组此位置上是否已有元素
	如果此位置上没有其他元素，则元素a添加成功。---->情况1
	如果此位置上有其他元素b(或以链表形式存在的多个元素)，则比较元素a与元素b的hash值
		如果hash值不相同，则元素a添加成功 ---->情况2
		如果hash值相同，进而需要调用元素a所在类的equals()方法
			equals()返回true，元素a添加失败
			equals()返回false，则元素a添加成功。 ---->情况3

对于添加成功的情况2和情况3而言：元素a 与已经存在指定索引位置上的数据以链表的方式存储
jdk 7 ：元素a放到数组中，指向原来的元素
jdk 8 ：原来的元素在数组中，指向元素a
总结：七上八下

HashSet底层：数组+链表的结构


================================================================================	

返回一个文件
response.send(__dirname+'/index.html')	
================================================================================

    <div></div>
    <script>
        function handle(data){
            const div=document.querySelector('div');
            div.innerHTML=data.name
        }
    </script>
	//script属于get请求
    <script src="http://127.0.0.1:1666/"></script>

app.all("/",(request,response)=>{
    //设置响应头 允许跨域
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Headers","*")
    //设置响应
    const data={
        name:'atguigu'
    }
    let str=JSON.stringify(data)
	//函数在客户端已经定义好
        response.send(`handle(${str})`);
});	


============================================================
appDiv.style.border="solid 1px #f00"
//1.创建script标签
const script=document.createElement('script');
//2.设置标签的src属性
script.src="http://www.baidu.com";
//3.将script插入到文档中
document.body.appendChild(script);


============================================================
条件渲染：
    1.v-if
        写法：
            (1).v-if="表达式"
            (2).v-else-if="表达式"
            (3).v-else="表达式"
       适用于：切换频率较低的场景
       特点：不展示的DOM元素直接被移除。
       注意：v-if可以和:v-else-if,v-else一起使用,但要求结构不能被“打断”。
    2.v-show
        写法：v-show="表达式"
        适用于：切换频率较高的场景。
        特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
    3.备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到。       
============================================================
环境变量：
    当我们在命令行窗口打开一个文件，或调用一个程序时，
        系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
        如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
        如果没有找到则报错
    所以我们可以将一些经常需要访问的程序和文件的路径添加到path中
        这样我们就可以在任意位置来访问这些文件和程序了
============================================================
@RequestParam是将请求参数和控制器方法的形参创建映射关系
@RequestParam一共有三个属性：
value:指定为形参赋值的请求参数的参数名
required:设置是否必须传输此请求参数，默认值为true
defaultValue:不管required属性值为true或false,当value所指定的请求参数没有传输或传输的值为""时，则使用默认值为形参赋值
@RequestParam(value="user_name",required=false,defalutValue="hehe")
============================================================
每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中。
然后传递到service方法（doGet和doPost）中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的
信息。
============================================================
#应用场景 会爬取一个列表返回给我们
#循环一个列表
a_list=['周杰伦','林俊杰','王力宏'];

#遍历列表中的元素
for i in a_list:
	print(i)

#判断列表中的元素的个数	
print(len(a_list))	

for i in range(len(a_list)):
	print(i)
============================================================
HttpServletRequest类的常用方法
	getRequestURI() 获取请求的资源路径
	getRequestURL() 获取请求的统一资源定位符（绝对路径）
	gerRemoteHost()	获取客户端的ip地址
	getHeader()		获取请求头
	getParameter()	获取请求参数
	getParameterValues()	获取请求的参数（多个值的时候使用）
	getMethod()		获取请求的方式GET 或 POST
	getAttribute(key)		获取域数据
	getRequestDispatcher()	获取请求转发对象
============================================================
项目描述
1）此项目为一个前后台分离的后台管理的SPA，包括前端PC应用和后端应用
2）包括用户管理/商品分类管理/商品管理/权限管理等功能模块
3）前端：使用React全家桶+Antd+Axios+ES6+Webpack等技术
4）后端：使用Node+Express+Mongdb等技术
5）采用模块化、组件化、工程化的模式开发

============================================================
v-for指令：
	1.用于展示列表数据
	2.语法：v-for="(item, index) in xxx" :key="yyy"
	3.可遍历：数组、对象、字符串（用的很少）、指定次数（用的很少）
============================================================
.pink{
    width:66px;
    height:66px;
    background:green;
    float:left;
    margin-right:16px;
}
<div class="pink"></div>
<div class="pink"></div>
<div class="pink"></div>
window.onload=function(){
    var element=document.querySelectorAll(".pink")
    for(let i = 0;i<element.length;i++){
        element[i].onclick=function(){
            element[i].style.background="pink"
        }
    }
}
============================================================

安装json-server

npm install -g json-server

db.json
posts代表文章 comments代表评论 profile代表个人
postId关联文章id author关联name
{
 "posts":[
	{"id":1,"title":"json-server","author":"typicode"}
	 ],
  "comments":[
	{"id":1,"body":"some comment","postId":1}
	],
  "profile":{"name":"typicode"}
}

启动json-server

json-server --watch db.json

============================================================

npm init 取名 webpack-test

全局安装：npm i webpack webpack-cli -g

本地安装：npm i webpack webpack-cli -D

index.js: webpack入口起点文件

1. 运行指令
	开发环境：webpack ./src/index.js -o ./build/built.js --mode=development
	webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js
	整体打包环境，是开发环境
	生产环境：webpack ./src/index.js -o ./build/built.js --mode=production
	webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js
	整体打包环境，是生产环境
2. 结论：
	1. webpack能处理js/json资源，不能处理css/img等其他资源
	2. 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~
	3. 生产环境比开发环境多一个压缩js代码

import data from './data.json'
console.log(data)           
============================================================

SELECT * FROM `user` WHERE NAME = '1' OR ' and password = '=1 OR '1' = '1'
============================================================

    <script src="https://cdn.bootcdn.net/ajax/libs/axios/0.9.1/axios.js"></script>
    <button onclick="testGet()">get</button>
    <button onclick="testPost()">post</button>
    <script>
        function testGet() {
            axios.get("http://localhost:3000/posts/1")
            .then(response=>{
                console.log("/posts get", response.data)
            })
        }
        function testPost(){
	        axios.post("http://localhost:3000/posts",{"title":"json-server3","author":"typicode3"})
	        .then(response=>{
		    console.log('/posts post', response.data)
	    })
}
    </script>
============================================================
面试题：react、vue中的key有什么作用？(key的内部原理)

1. 虚拟DOM中的key的作用：
	key是由虚拟DOM对象的标识，当状态中的数据发生变化时，Vue会根据【新数据】生成【新的虚拟DOM】
	随后Vue进行【新虚拟DOM】与【旧虚拟DOM】的差异比较，比较规则如下：

2.对比规则：
	(1). 旧虚拟DOM中找到了与新虚拟DOM相同的key：
		若虚拟DOM中的内容没变，直接使用之前的真实DOM!
		若虚拟DOM中的内容变了，则生成新的真实DOM，然后替换掉页面中之前的真实DOM。

	(2). 旧虚拟DOM中未找到与新虚拟DOM相同的key
		创建新的真实DOM，随后渲染到页面

3. 用index作为key可能会引发的问题：
	1. 若对数据进行：逆序添加、逆序删除等破坏顺序操作：
			会产生没有必要的真实DOM更新 ==> 界面效果没问题，但效率低。

	2. 如果结构中还包括输入类的DOM：
			会产生错误DOM更新 ==> 界面有问题。

4. 开发中如何选择key?：
	1. 最好使用每条数据的唯一的标识作为key，比如id、手机号、身份证号、学号等唯一值。
	2. 如果不存在对数据的逆序添加、逆序删除等破坏顺序操作，仅用于渲染列表用于展示，
		使用index作为key是没有问题的。

============================================================
除了解决Statement的拼串、sql问题之外，PreparedStatement还有哪些好处呢？
1. PreparedStatement可以操作Blob的数据，而Statement做不到
2. PreparedStatement可以实现更高效率的批量操作
============================================================
获取长度：len

查找内容：find 如果存在，则返回改内容在字符串中的第一次出现的索引值，否则返回-1

判断：startswith，endswith 判断字符串以谁开头、结尾

计算出现次数：count 

替换内容：replace 

切割字符串：split

修改大小写：upper，lower

空格处理：strip
============================================================

React:通过React.createRef获取节点
    <div id="example"></div>
    <script type="text/babel">
        class Demo extends React.Component{
            //React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点，该容器时“专人专用”的
            myRef1=React.createRef()
            myRef2=React.createRef()
            showInfo=()=>{
                alert(this.myRef1.current.value);
            }
            showData=()=>{
                alert(this.myRef2.current.value);
            }
            render(){
                return(
                    <div>
                        <input ref={this.myRef1} type='text' placeholder='请输入数据'/>
                        <button onClick={this.showInfo}>点击显示数据</button>
                        <input onBlur={this.showData} ref={this.myRef2} type='text' placeholder='失去焦点显示数据'/>
                        </div>
                )
            }
        }
    ReactDOM.render(<Demo/>,document.getElementById('example'))
    </script>
============================================================
ps.execute()
如果执行的是查询操作，有返回结果，则此方法返回true
如果执行的是增、删、改操作，没有返回结果，则此方法返回false
============================================================
git 常用基本命令

git config --global user.name "username" //配置用户名

git config --global user.email "xx@gmail.com" //配置邮箱

git init //初始化生成一个本地仓库

git add //添加到暂存区

git commit -m "message" //提交到本地仓库

git remote add origin url //关联到远程仓库

============================================================
1. 通过onXxx属性指定事件处理函数（注意大小写）
	a. React使用的是自定义（合成）事件，而不是使用的原生DOM事件 ---为了更好的兼容性
	b. React中的事件是通过事件委托方式处理的（委托给组件最外层的元素） ---为了更高效
2. 通过event.target得到发生时间的DOM元素对象 --- 不要过度使用ref
============================================================

//1. 数组的解构
const F4=['小沈阳','刘能','赵四','宋小宝']
let [xiao,liu,zhao,song]=F4
console.log(xiao)

//2. 对象的解构
const zhao={
    name:'赵本山',
    age:68,
    xiaopin:function(){
        console.log("我可以演小品")
    }
}
let {xiaopin}=zhao
xiaopin()
============================================================
使用create-react-app（脚手架）搭建项目

create-react-app是从react官方提供的用于搭建基于react+webpack+es6项目的脚手架

npm install -g create-ract-app : 全局下载工具

create-react-app react-admin : 下载模板项目

cd react-admin

npm start
============================================================
查找元素

所谓的查找，就是看看指定的元素是否存在，主要包含以下几个方法：

in 和 not in 

info=input("请输您想吃的菜：")
caipu=['小鸡炖蘑菇','锅包肉']
if info in caipu:
    print('在')
else:
    print('不在')


============================================================
Servlet1 和 Servlet2可以共同完成一个完整的业务功能
请求转发的特点：
1、 浏览器地址没有变化
2、 他们是一次请求
3、 他们共享Request域中的数据
4、 可以转发到WEB-INF目录下
5、 不可以访问工程以外的资源
============================================================
============================================================
============================================================
============================================================
