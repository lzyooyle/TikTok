
返回一个文件
response.send(__dirname+'/index.html')	
================================================================================

    <div></div>
    <script>
        function handle(data){
            const div=document.querySelector('div');
            div.innerHTML=data.name
        }
    </script>
	//script属于get请求
    <script src="http://127.0.0.1:1666/"></script>

app.all("/",(request,response)=>{
    //设置响应头 允许跨域
    response.setHeader("Access-Control-Allow-Origin", "*");
    response.setHeader("Access-Control-Allow-Headers","*")
    //设置响应
    const data={
        name:'atguigu'
    }
    let str=JSON.stringify(data)
	//函数在客户端已经定义好
        response.send(`handle(${str})`);
});	




============================================================
条件渲染：
    1.v-if
        写法：
            (1).v-if="表达式"
            (2).v-else-if="表达式"
            (3).v-else="表达式"
       适用于：切换频率较低的场景
       特点：不展示的DOM元素直接被移除。
       注意：v-if可以和:v-else-if,v-else一起使用,但要求结构不能被“打断”。
    2.v-show
        写法：v-show="表达式"
        适用于：切换频率较高的场景。
        特点：不展示的DOM元素未被移除，仅仅是使用样式隐藏掉
    3.备注：使用v-if的时候，元素可能无法获取到，而使用v-show一定可以获取到。       
============================================================
环境变量：
    当我们在命令行窗口打开一个文件，或调用一个程序时，
        系统会首先在当前目录下寻找文件程序，如果找到了则直接打开
        如果没有找到则会依次到环境变量path的路径中寻找，直到找到为止
        如果没有找到则报错
    所以我们可以将一些经常需要访问的程序和文件的路径添加到path中
        这样我们就可以在任意位置来访问这些文件和程序了

============================================================
每次只要有请求进入Tomcat服务器，Tomcat服务器就会把请求过来的HTTP协议信息解析好封装到Request对象中。
然后传递到service方法（doGet和doPost）中给我们使用。我们可以通过HttpServletRequest对象，获取到所有请求的
信息。
============================================================
#应用场景 会爬取一个列表返回给我们
#循环一个列表
a_list=['周杰伦','林俊杰','王力宏'];

#遍历列表中的元素
for i in a_list:
	print(i)

#判断列表中的元素的个数	
print(len(a_list))	

for i in range(len(a_list)):
	print(i)

============================================================
项目描述
1）此项目为一个前后台分离的后台管理的SPA，包括前端PC应用和后端应用
2）包括用户管理/商品分类管理/商品管理/权限管理等功能模块
3）前端：使用React全家桶+Antd+Axios+ES6+Webpack等技术
4）后端：使用Node+Express+Mongdb等技术
5）采用模块化、组件化、工程化的模式开发



============================================================

安装json-server

npm install -g json-server

db.json
posts代表文章 comments代表评论 profile代表个人
postId关联文章id author关联name
{
 "posts":[
	{"id":1,"title":"json-server","author":"typicode"}
	 ],
  "comments":[
	{"id":1,"body":"some comment","postId":1}
	],
  "profile":{"name":"typicode"}
}

启动json-server

json-server --watch db.json

============================================================

npm init 取名 webpack-test

全局安装：npm i webpack webpack-cli -g

本地安装：npm i webpack webpack-cli -D

index.js: webpack入口起点文件

1. 运行指令
	开发环境：webpack ./src/index.js -o ./build/built.js --mode=development
	webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js
	整体打包环境，是开发环境
	生产环境：webpack ./src/index.js -o ./build/built.js --mode=production
	webpack会以 ./src/index.js 为入口文件开始打包，打包后输出到 ./build/built.js
	整体打包环境，是生产环境
2. 结论：
	1. webpack能处理js/json资源，不能处理css/img等其他资源
	2. 生产环境和开发环境将ES6模块化编译成浏览器能识别的模块化~
	3. 生产环境比开发环境多一个压缩js代码

import data from './data.json'
console.log(data)           

============================================================

    <script src="https://cdn.bootcdn.net/ajax/libs/axios/0.9.1/axios.js"></script>
    <button onclick="testGet()">get</button>
    <button onclick="testPost()">post</button>
    <script>
        function testGet() {
            axios.get("http://localhost:3000/posts/1")
            .then(response=>{
                console.log("/posts get", response.data)
            })
        }
        function testPost(){
	        axios.post("http://localhost:3000/posts",{"title":"json-server3","author":"typicode3"})
	        .then(response=>{
		    console.log('/posts post', response.data)
	    })
}
    </script>

============================================================

React:通过React.createRef获取节点
    <div id="example"></div>
    <script type="text/babel">
        class Demo extends React.Component{
            //React.createRef调用后可以返回一个容器，该容器可以存储被ref所标识的节点，该容器时“专人专用”的
            myRef1=React.createRef()
            myRef2=React.createRef()
            showInfo=()=>{
                alert(this.myRef1.current.value);
            }
            showData=()=>{
                alert(this.myRef2.current.value);
            }
            render(){
                return(
                    <div>
                        <input ref={this.myRef1} type='text' placeholder='请输入数据'/>
                        <button onClick={this.showInfo}>点击显示数据</button>
                        <input onBlur={this.showData} ref={this.myRef2} type='text' placeholder='失去焦点显示数据'/>
                        </div>
                )
            }
        }
    ReactDOM.render(<Demo/>,document.getElementById('example'))
    </script>




============================================================
使用create-react-app（脚手架）搭建项目

create-react-app是从react官方提供的用于搭建基于react+webpack+es6项目的脚手架

npm install -g create-ract-app : 全局下载工具

create-react-app react-admin : 下载模板项目

cd react-admin

npm start

============================================================


打包发布

npm run build

npm install -g serve

serve build

访问：http://localhost:5000

============================================================
查找元素

所谓的查找，就是看看指定的元素是否存在，主要包含以下几个方法：

in 和 not in 

info=input("请输您想吃的菜：")
caipu=['小鸡炖蘑菇','锅包肉']
if info in caipu:
    print('在')
else:
    print('不在')


============================================================
在node中，通过require()函数来引入外部的模块

require()可以传递一个文件的路径作为参数，node将会自动根据该路径来引入外部模块

这里的路径，如果使用相对路径，必须以.或..开头

使用require()引入模块以后，该函数会返回一个对象，这个对象代表的是引入的模块

var md = require('./module.js')
============================================================
在Node中，一个js文件就是一个模块

在Node中，每一个js文件中的js代码都是独立运行在一个函数中

	而不是全局作用域，所以一个模块中的变量和函数在其他模块中无法访问

我们可以通过exports 来向外部暴露变量和文件

	只需要将需要暴露给外部的变量或方法设置为exports的属性即可

向外部暴露属性或方法

exports.x='123'

exports.fn=function(){

}

============================================================
    <div id="test"></div>
    <script type="text/babel">
        class Count extends React.Component{
            constructor(props) {
                console.log('Conunt-constructor');
                super(props)
            }

            //组件将要挂载的钩子
            componentWillMount(){
                console.log('Count-componentWillMount');   
            }            

            //组件挂载完毕的钩子
            componentDidMount(){
                console.log('Count-componentDidMount');
            }
            render(){
                console.log('Count-render');
                return(
                    <div>
                        <h1>demo</h1>
                    </div>
                )
            }


        }
        ReactDOM.render(<Count/>,document.getElementById('test'))
        
    </script>
============================================================
============================================================
