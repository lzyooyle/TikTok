## 4.1 HashMap底层原理
+ 1.jdk1.7采用数组+链表的方式，采用头插法，jdk1.8采用数组+链表+红黑树的方式，采用尾插法
+ 2.当元素个数达到容量的0.75，就会扩容为原来的2倍，当数组容量达到64，链表长度大于等于8，链表会转化为树，当链表的长度小于6，树会转成链表
+ map.put(k,v)方法的原理：先将k和v压缩到Node对象中，然后调用hashcode方法得到hash值，通过hash算法将hash值转换为数组下标
+ 如果下标位置没有元素，这个节点会添加到那个位置，如果存在链表，就调用equals方法，将k的值和链表上的每个节点，进行比较
+ 如果返回false，新节点会被插入到链表的尾部，如果返回true，这个节点上的值将会被覆盖
+ map.get(k)方法的原理：首先调用hashcode方法得到hash值，然后通过hash算法得到数组中下标的位置，快速定位到位置，如果没有元素，返回null
+ 快速定位位置，如果该位置上没有元素，返回null，如果有一个单向链表，就用参数k的值和单向链表上的每个节点进行比较
+ 如果返回false，get方法返回null，如果有一个节点的值符合，返回true
