## 自旋锁
自旋锁采用忙循环，synchronized涉及到线程的用户态和内核态的切换，浪费时间，资源，影响效率。wait，sleep，yield会放弃CPU的控制权，而自旋锁不会。

## synchronized锁升级的原理
偏向锁顾名思义会偏向于第一个访问他的线程，设置字段Threadid，如果线程自带的id和偏向锁自带的id不一致，则升级为轻量级锁，轻量级锁采用自旋的方式获取锁，在获取一定的次数失败后，会升级为重量级锁。

## CAS会产生什么问题
### 1. ABA问题：
one线程从V地址取出值A，two线程也从V地址取出值A，改成值B，再改成值A，one线程通过CAS发现值A没变，这个过程是存在潜在问题的。
### 2. 资源消耗过大：
在资源竞争激烈的场景下，CAS可能会频繁的的发生，对CPU资源是一种极大的浪费。（自旋锁不会放弃对CPU的控制）
### 3. 只能保证一个共享变量的原子操作：
CAS是无法保证，对多个共享变量的原子操作的，这个时候，就可以用到锁。

## 进程的创建
+ 操作系统允许一个进程创建另一个进程，允许子进程继承父进程拥有的资源
+ 首先会申请一个空白的PCB（进程控制块），向PCB中写于进程的唯一标识
+ 为进程分配内存资源，将PCB插入就绪队列，等待操作系统的调度运行

## 终止进程
+ 终止进程有三种方式，正常结束，异常结束，外界干预（kill -9）
+ 当子进程终止时，其从父进程处继承的资源，应该还给父进程
+ 当父进程终止时，其子进程就成了孤儿进程，会被1号进程收养，并由1号进程收集其状态信息
+ 查找要终止进程的PCB，如果该进程处于执行状态，则立即终止该进程的执行
+ 将PCB资源分配给其他进程，如果该进程还有子进程，则将子进程交给1号进程接管
+ 将该进程所拥有的全部资源还给操作系统，将该进程从所在的队列删除

## 阻塞进程
+ 找到要阻塞进程标识符对应的PCB，如果该进程处于执行状态，则保护现场
+ 将该进程的状态转为阻塞状态，停止运行，将PCB插入到阻塞队列
