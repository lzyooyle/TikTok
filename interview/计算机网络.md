## TCP/IP 网络模型有哪几层
+ 应用层在用户态，传输层在内核态，应用层的数据会传给传输层，传输层为应用层提供网络支持
+ 传输层有两个协议TCP(传输控制协议)和UDP，TCP比UDP多了流量控制，超时重传，拥塞控制
+ 当文件的大小超过TCP最大报文段长度，我们会把这个文件划分成若干块，每块称之为报文段
+ 这样当有一块数据出现丢失或损坏的时候，我们只需重传这块数据即可，不用将整个文件传过去
+ 应用层有多个数据接收方或传输方，系统采用分配端口的方式来作为区分他们的标记
+ 80端口是web服务器的端口，22端口是远程登陆服务器的端口，浏览器每个标签页都是一个独立的进程
+ 网络层会将传输层的报文作为数据部分，加上IP地址传输，如果IP报文超过MTU(以太网最大1500字节)
+ 将会再次分片，得到要发送出去的IP报文
+ 网络号用来标识属于哪一个子网，主机号用来标识同一个子网下的不同主机

## Https解决Http的哪些问题
+ Https采用了对称加密和非对称加密的混合加密方式
+ 在通信建立前，采用非对称加密交换会话密钥，后续不再使用非对称加密方式
+ 在通信过程中，全部采用对称加密方式交换会话密钥，加密明文数据
+ 对称加密只使用一个密钥，运算速度快，无法做到安全的密钥交换
+ 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发，私钥只有一个
+ 保证了密钥交换的安全问题，但运算速度慢

## tcp的三次握手
+ 一开始客户端和服务端都处于close状态，服务端率先监听某个端口，处于Listen状态
+ 第一次发报文：客户端会随机生成一个序列号（client_isn），将该序列号放入tcp头部的序列号字段
+ 并将SYN标志位标记为1，表示这是一个SYN报文，将报文发送给服务端，客户端此时处于SYN_SENT状态
+ 第二次发报文：服务端在收到报文后，也会随机生成一个序列号（server_isn）
+ 将序列号写入tcp头部的序号字段，其次将tcp头部的确认应答字号设置为client_isn+1
+ 将SYN和ACK标志位设为1，将报文发送给客户端，服务端处于SYN_RVD状态
+ 第三次发送报文：客户端在收到服务端的报文后，还需要发送最后一次应答报文，将tcp头部的ACK的标志位
+ 设置为1，将自动应答号填入server_isn+1，随后向服务端发送报文，这次报文可携带数据
+ 客户端处于ESTABLISHED状态，服务端在收到报文后，也处于ESTABLISHED状态

## 流量控制
+ 发送方不能无脑的把数据发送给接收方，要考虑到接收方的处理能力，如果一直无脑的发送数据给对方
+ 对方又处理不过来，就会触发重发机制，造成流量的无端浪费，为了避免这种现象的发生，tcp提供了
+ 一种机制，能让发送方知道接收方，实际的处理能力，控制发送的数据量

## 滑动窗口
+ 指无需等待确认应答，可以发送的数据的最大值，滑动窗口实际上是操作系统开辟的缓冲空间
+ 在发送方没有收到确认应答之前，会缓存发送的数据，如果按期收到确认应答，会删除缓冲数据
+ window这个字段，告诉发送方，自己还有多少缓冲区可以处理数据，这样发送端就可以根据接受端
+ 的能力来发送数据，就不会导致接收端处理不过来了
+ 一般来说，窗口的大小是由接收方来决定的，发送根据接收方窗口的大小来发送数据
+ 发送方缓存的数据分为四种情况：数据已发送并接收到了ACK确认应答，数据已发送还未收到
+ ACK确认应答，数据未发送但在接收方的处理范围内，数据未发送超出了接收方的处理范围
+ 接收方的滑动窗口比较简单：#1#2已经接受并确认的数据（等待应用程序的读取）
+ #3未收到数据但可以处理的数据，#4未收到数据不可以处理的数据
+ 发送窗口和接受窗口中存放的数据，都是放在操作系统内存缓冲区中的，而缓冲区中的大小
+ 操作系统是会调整的，接收方向发送方通告窗口大小，是通过ACK报文通告的

## 重传机制
+ 超时重传就是在给对方发送数据时，设定一个定时器，如果在规定的时间内，没有收到对反的
+ ACK确认应答报文，就重新发送该数据，称为超时重传，一种是数据丢包，一种是自动应答丢失
+ RTT指的是数据的发送时刻到确认接收的时刻的差值，就是包的往返时间
+ 当超时重传时间（RTO）设置时间过大时，数据包丢了老半天，才会重发，传输效率低
+ 当RTO设置过小的时候，会导致没有丢包的情况下，触发重发，更多的重发导致更多的超，导致网络拥塞
+ RTO的值应该是一个动态变化的值，每当遇到超时重传的时候，都会将下次超时重传的时间间隔
+ 设置为原来的2倍，如果遇到两次超时重传，说明当前网络环境差，不宜频繁的发送数据
+ 快速重发机制是在连续收到3个ACK报文后，在超时重发时间里，重发丢失的数据报文
+ 快速重传面临一个问题：是重传一个，还是重传多个的问题，重传一个效率低，重传多个浪费资源
+ SACK（选择性确认）实在tcp头部的选项字段里，添加一个SACK字段，记录哪些数据传过了
+ 将该字段传给发送方，发送方就可以知道这些信息，哪些数据没有传过，重传丢失的数据

## 2.1 TCP连接断开时为什么需要一个timewait状态？
+ 防止旧的数据被具有相同四元组的新的连接所接收，保证被动关闭一方能正确关闭连接
+ 序列号是TCP头部的一个字段，标识了从发送端到接收端的数据流，为传输方向的每个字节编号
+ TCP建立连接的时候，客户端和服务端会根据时钟随机生成一个32位的序列号，根据序列号
+ 是无法判断数据新旧的，TIME_WAIT设计为2MSL是因为要确保两个方向的数据包自然消失
+ 让新产生的数据包一定是新的连接产生的，

## 2.2 TCP 和 UDP 区别!
+ 1.连接：tcp是基于传输层协议的连接，必须在传输数据前，建立连接，udp无需连接，即可传输
+ 2.服务对象：tcp是点对点的连接，即一个连接只有两个点，udp支持一对一，一对多，多对多的相互连接
+ 3.可靠性：tcp是可靠的数据传输，数据可以无错误，无丢失，不重复，按顺序的到达
+ udp尽最大努力传输，不能确保数据的可靠传输，但是我们可以基于udp传输协议，实现可靠性传输协议
+ 4.流量控制，拥塞控制：tcp有流量控制和拥塞控制机制来确保数据的安全传输，udp则没有，即使
+ 网络非常拥挤了，也不会影响udp的发送速率
+ 5.首部开销：tcp的头部很长，会有一定的开销，首部在没有使用可选项字段的时候，是20个字节
+ 如果可选项字段被使用，字段则会变长的，udp头部只有8个字节，而且它是固定的，开销比较小
+ 6.传输方式：tcp是流式传输，没有边界，但保证了有序性和可靠性，udp是通过一个包一个包发送
+ 有边界，但是可能会丢包和乱序
+ 7.分片不同：如果tcp数据的大小大于MSS，tcp包会在传输层切片，收到tcp包后，目标主机也会在
+ 传输层组装tcp包，如果这个过程中有一个分片丢失了，只有这个丢是的分片需要重传，如果udp的数据
+ 大小大于MTU，会在ip层进行切片，在收到udp数据后，目标主机也会在ip层组装数据，然后将数据发送给传输层

## 2.3 get请求和post请求的区别!
+ 1.请求参数的位置不同：get的请求参数是放在url里的，post请求参数是放在请求体里的
+ 2.浏览器缓存：get请求可以被缓存在浏览器里，post请求不能被缓存
+ 3.参数长度：get请求参数放在url里，所以它会被浏览器限制长度，不同浏览器限制的长度，也不一样
+ 理论上讲：post请求参数的长度是没有限制的，因为http协议规范里没有大小限制
+ 4.参数安全：也因为get请求的参数是放在url里的，所以是可以被看见的，再加上被浏览器的缓存，安全性太差
+ post请求参数是放在请求体里的，不会被缓存，所以安全性更可靠
+ 5.浏览器访问：get请求可以直接通过浏览器访问，支持刷新和后退，post请求不能被浏览器直接访问

## 2.4 浏览器输入URL后发生了什么!
+ DNS解析域名，TCP建立连接（三次握手），发送Http请求，服务器处理请求，返回响应结果
+ TCP关闭连接（四次挥手），渲染浏览器
