## TCP/IP 网络模型有哪几层
+ 应用层在用户态，传输层在内核态，应用层的数据会传给传输层，传输层为应用层提供网络支持
+ 传输层有两个协议TCP(传输控制协议)和UDP，TCP比UDP多了流量控制，超时重传，拥塞控制
+ 当文件的大小超过TCP最大报文段长度，我们会把这个文件划分成若干块，每块称之为报文段
+ 这样当有一块数据出现丢失或损坏的时候，我们只需重传这块数据即可，不用将整个文件传过去
+ 应用层有多个数据接收方或传输方，系统采用分配端口的方式来作为区分他们的标记
+ 80端口是web服务器的端口，22端口是远程登陆服务器的端口，浏览器每个标签页都是一个独立的进程
+ 网络层会将传输层的报文作为数据部分，加上IP地址传输，如果IP报文超过MTU(以太网最大1500字节)
+ 将会再次分片，得到要发送出去的IP报文
+ 网络号用来标识属于哪一个子网，主机号用来标识同一个子网下的不同主机

## Https解决Http的哪些问题
+ Https采用了对称加密和非对称加密的混合加密方式
+ 在通信建立前，采用非对称加密交换会话密钥，后续不再使用非对称加密方式
+ 在通信过程中，全部采用对称加密方式交换会话密钥，加密明文数据
+ 对称加密只使用一个密钥，运算速度快，无法做到安全的密钥交换
+ 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发，私钥只有一个
+ 保证了密钥交换的安全问题，但运算速度慢

## tcp的三次握手
+ 一开始客户端和服务端都处于close状态，服务端率先监听某个端口，处于Listen状态
+ 第一次发报文：客户端会随机生成一个序列号（client_isn），将该序列号放入tcp头部的序列号字段
+ 并将SYN标志位标记为1，表示这是一个SYN报文，将报文发送给服务端，客户端此时处于SYN_SENT状态
+ 第二次发报文：服务端在收到报文后，也会随机生成一个序列号（server_isn）
+ 将序列号写入tcp头部的序号字段，其次将tcp头部的确认应答字号设置为client_isn+1
+ 将SYN和ACK标志位设为1，将报文发送给客户端，服务端处于SYN_RVD状态
+ 第三次发送报文：客户端在收到服务端的报文后，还需要发送最后一次应答报文，将tcp头部的ACK的标志位
+ 设置为1，将自动应答号填入server_isn+1，随后向服务端发送报文，这次报文可携带数据
+ 客户端处于ESTABLISHED状态，服务端在收到报文后，也处于ESTABLISHED状态

## 流量控制
+ 发送方不能无脑的把数据发送给接收方，要考虑到接收方的处理能力，如果一直无脑的发送数据给对方
+ 对方又处理不过来，就会触发重发机制，造成流量的无端浪费，为了避免这种现象的发生，tcp提供了
+ 一种机制，能让发送方知道接收方，实际的处理能力，控制发送的数据量

## 滑动窗口
+ 指无需等待确认应答，可以发送的数据的最大值，滑动窗口实际上是操作系统开辟的缓冲空间
+ 在发送方没有收到确认应答之前，会缓存发送的数据，如果按期收到确认应答，会删除缓冲数据

## 重传机制
+ 超时重传就是在给对方发送数据时，设定一个定时器，如果在规定的时间内，没有收到对反的
+ ACK确认应答报文，就重新发送该数据，称为超时重传，一种是数据丢包，一种是自动应答丢失
+ RTT指的是数据的发送时刻到确认接收的时刻的差值，就是包的往返时间
+ 当超时重传时间（RTO）设置时间过大时，数据包丢了老半天，才会重发，传输效率低
