## 2.12 进程间通信的方式有哪几种
+ 1.无名管道：管道是一种半双工的形式，数据只能单向流动，只能用在亲缘关系的进程，比如父子进程
+ 2.高级管道：当另一个程序被当作一个进程，在当前程序中运行，它被看作当前程序的子进程
+ 3.有名管道：也是一种半双工的通信方式，但是它们允许在没有关系的进程之间通信
+ 4.消息队列：一个消息队列是一个链表存储在内核，并用消息队列标识符标识，消息队列克服了信号传递信息少
+ 管道只能运输无格式字节流，缓存大小有限制等缺点
+ 5.信号量：信号量是一个计数器，可以用来控制多个线程访问共享资源，它经常被当作锁机制使用，当一个进程正在访问
+ 共享资源的时候，防止另一个进程访问，因此它主要用在进程间或者同一个进程中不同的线程的同步
+ 6.信号：信号是一种通信复杂的格式，被用来通知一个接受进程有事件发生
+ 7.共享内存：共享内存是一个内存的映射，是被一个进程创建的，可以被多个进程访问，共享内存是IPC中最快的
+ 它常被用在和其它通信机制配合使用，比如：信号量，两个进程间获得同步和通信
+ 8.套接字：套接字端口也是一个内部进程通信机制，不同于其它通信机制，它可以被用来处理不同机器的进程通信
## 2.11 Cookie与Session的区别
+ 1.cookie的数据保存在客户端浏览器，session的数据被放置在服务器，然而服务器的session实现依赖于客户端的cookie
+ 2.cookie是不安全的，别人可以通过分析cookie的存储位置进行欺骗，考虑到安全性，应当用session
+ 3.session在一定的时间内被放存放在服务器上，随着访客的增加，它会降低服务器的性能，为了减缓服务器的压力，应当用cookie
+ 4.单个客户端的cookie只有3k，也就是说一个网站在客户端的存储的cookie不能超过3k
## TCP/IP 网络模型有哪几层
+ 应用层在用户态，传输层在内核态，应用层的数据会传给传输层，传输层为应用层提供网络支持
+ 传输层有两个协议TCP(传输控制协议)和UDP，TCP比UDP多了流量控制，超时重传，拥塞控制
+ 当文件的大小超过TCP最大报文段长度，我们会把这个文件划分成若干块，每块称之为报文段
+ 这样当有一块数据出现丢失或损坏的时候，我们只需重传这块数据即可，不用将整个文件传过去
+ 应用层有多个数据接收方或传输方，系统采用分配端口的方式来作为区分他们的标记
+ 80端口是web服务器的端口，22端口是远程登陆服务器的端口，浏览器每个标签页都是一个独立的进程
+ 网络层会将传输层的报文作为数据部分，加上IP地址传输，如果IP报文超过MTU(以太网最大1500字节)
+ 将会再次分片，得到要发送出去的IP报文
+ 网络号用来标识属于哪一个子网，主机号用来标识同一个子网下的不同主机

## Https解决Http的哪些问题
+ Https采用了对称加密和非对称加密的混合加密方式
+ 在通信建立前，采用非对称加密交换会话密钥，后续不再使用非对称加密方式
+ 在通信过程中，全部采用对称加密方式交换会话密钥，加密明文数据
+ 对称加密只使用一个密钥，运算速度快，无法做到安全的密钥交换
+ 非对称加密使用两个密钥，公钥和私钥，公钥可以任意分发，私钥只有一个
+ 保证了密钥交换的安全问题，但运算速度慢

## tcp的三次握手
+ 一开始客户端和服务端都处于close状态，服务端率先监听某个端口，处于Listen状态
+ 第一次发报文：客户端会随机生成一个序列号（client_isn），将该序列号放入tcp头部的序列号字段
+ 并将SYN标志位标记为1，表示这是一个SYN报文，将报文发送给服务端，客户端此时处于SYN_SENT状态
+ 第二次发报文：服务端在收到报文后，也会随机生成一个序列号（server_isn）
+ 将序列号写入tcp头部的序号字段，其次将tcp头部的确认应答字号设置为client_isn+1
+ 将SYN和ACK标志位设为1，将报文发送给客户端，服务端处于SYN_RVD状态
+ 第三次发送报文：客户端在收到服务端的报文后，还需要发送最后一次应答报文，将tcp头部的ACK的标志位
+ 设置为1，将自动应答号填入server_isn+1，随后向服务端发送报文，这次报文可携带数据
+ 客户端处于ESTABLISHED状态，服务端在收到报文后，也处于ESTABLISHED状态

## 流量控制
+ 发送方不能无脑的把数据发送给接收方，要考虑到接收方的处理能力，如果一直无脑的发送数据给对方
+ 对方又处理不过来，就会触发重发机制，造成流量的无端浪费，为了避免这种现象的发生，tcp提供了
+ 一种机制，能让发送方知道接收方，实际的处理能力，控制发送的数据量

## 滑动窗口
+ 指无需等待确认应答，可以发送的数据的最大值，滑动窗口实际上是操作系统开辟的缓冲空间
+ 在发送方没有收到确认应答之前，会缓存发送的数据，如果按期收到确认应答，会删除缓冲数据
+ window这个字段，告诉发送方，自己还有多少缓冲区可以处理数据，这样发送端就可以根据接受端
+ 的能力来发送数据，就不会导致接收端处理不过来了
+ 一般来说，窗口的大小是由接收方来决定的，发送根据接收方窗口的大小来发送数据
+ 发送方缓存的数据分为四种情况：数据已发送并接收到了ACK确认应答，数据已发送还未收到
+ ACK确认应答，数据未发送但在接收方的处理范围内，数据未发送超出了接收方的处理范围
+ 接收方的滑动窗口比较简单：#1#2已经接受并确认的数据（等待应用程序的读取）
+ #3未收到数据但可以处理的数据，#4未收到数据不可以处理的数据
+ 发送窗口和接受窗口中存放的数据，都是放在操作系统内存缓冲区中的，而缓冲区中的大小
+ 操作系统是会调整的，接收方向发送方通告窗口大小，是通过ACK报文通告的

## 重传机制
+ 超时重传就是在给对方发送数据时，设定一个定时器，如果在规定的时间内，没有收到对反的
+ ACK确认应答报文，就重新发送该数据，称为超时重传，一种是数据丢包，一种是自动应答丢失
+ RTT指的是数据的发送时刻到确认接收的时刻的差值，就是包的往返时间
+ 当超时重传时间（RTO）设置时间过大时，数据包丢了老半天，才会重发，传输效率低
+ 当RTO设置过小的时候，会导致没有丢包的情况下，触发重发，更多的重发导致更多的超，导致网络拥塞
+ RTO的值应该是一个动态变化的值，每当遇到超时重传的时候，都会将下次超时重传的时间间隔
+ 设置为原来的2倍，如果遇到两次超时重传，说明当前网络环境差，不宜频繁的发送数据
+ 快速重发机制是在连续收到3个ACK报文后，在超时重发时间里，重发丢失的数据报文
+ 快速重传面临一个问题：是重传一个，还是重传多个的问题，重传一个效率低，重传多个浪费资源
+ SACK（选择性确认）实在tcp头部的选项字段里，添加一个SACK字段，记录哪些数据传过了
+ 将该字段传给发送方，发送方就可以知道这些信息，哪些数据没有传过，重传丢失的数据

## 2.1 TCP连接断开时为什么需要一个timewait状态？
+ 防止旧的数据被具有相同四元组的新的连接所接收，保证被动关闭一方能正确关闭连接
+ 序列号是TCP头部的一个字段，标识了从发送端到接收端的数据流，为传输方向的每个字节编号
+ TCP建立连接的时候，客户端和服务端会根据时钟随机生成一个32位的序列号，根据序列号
+ 是无法判断数据新旧的，TIME_WAIT设计为2MSL是因为要确保两个方向的数据包自然消失
+ 让新产生的数据包一定是新的连接产生的，

## 2.2 TCP 和 UDP 区别!
+ 1.连接：tcp是基于传输层协议的连接，必须在传输数据前，建立连接，udp无需连接，即可传输
+ 2.服务对象：tcp是点对点的连接，即一个连接只有两个点，udp支持一对一，一对多，多对多的相互连接
+ 3.可靠性：tcp是可靠的数据传输，数据可以无错误，无丢失，不重复，按顺序的到达
+ udp尽最大努力传输，不能确保数据的可靠传输，但是我们可以基于udp传输协议，实现可靠性传输协议
+ 4.流量控制，拥塞控制：tcp有流量控制和拥塞控制机制来确保数据的安全传输，udp则没有，即使
+ 网络非常拥挤了，也不会影响udp的发送速率
+ 5.首部开销：tcp的头部很长，会有一定的开销，首部在没有使用可选项字段的时候，是20个字节
+ 如果可选项字段被使用，字段则会变长的，udp头部只有8个字节，而且它是固定的，开销比较小
+ 6.传输方式：tcp是流式传输，没有边界，但保证了有序性和可靠性，udp是通过一个包一个包发送
+ 有边界，但是可能会丢包和乱序
+ 7.分片不同：如果tcp数据的大小大于MSS，tcp包会在传输层切片，收到tcp包后，目标主机也会在
+ 传输层组装tcp包，如果这个过程中有一个分片丢失了，只有这个丢是的分片需要重传，如果udp的数据
+ 大小大于MTU，会在ip层进行切片，在收到udp数据后，目标主机也会在ip层组装数据，然后将数据发送给传输层

## 2.3 get请求和post请求的区别!
+ 1.请求参数的位置不同：get的请求参数是放在url里的，post请求参数是放在请求体里的
+ 2.浏览器缓存：get请求可以被缓存在浏览器里，post请求不能被缓存
+ 3.参数长度：get请求参数放在url里，所以它会被浏览器限制长度，不同浏览器限制的长度，也不一样
+ 理论上讲：post请求参数的长度是没有限制的，因为http协议规范里没有大小限制
+ 4.参数安全：也因为get请求的参数是放在url里的，所以是可以被看见的，再加上被浏览器的缓存，安全性太差
+ post请求参数是放在请求体里的，不会被缓存，所以安全性更可靠
+ 5.浏览器访问：get请求可以直接通过浏览器访问，支持刷新和后退，post请求不能被浏览器直接访问

## 2.4 浏览器输入URL后发生了什么!
+ DNS解析域名，TCP建立连接（三次握手），发送Http请求，服务器处理请求，返回响应结果
+ TCP关闭连接（四次挥手），渲染浏览器

## 2.5 tcp三次握手的过程! （版本1）
+ 第一次握手：客户端随机初始化序列号（client_isn）,将序列号放在tcp头部的序列号字段中，设置SYN符号位为1
+ 表示SYN数据包，然后将SYN数据包发送给服务端，表示这个连接开始发送给服务端，这个数据包不包含应用层的数据
+ 客户端处于SYN_SENT状态
+ 第二次握手：收到客户端SYN数据包以后，服务端也会随机初始化自己的序列号（server_isn），然后将序列号填入
+ tcp头部的序列号字段，接下来将tcp头部确认应答字段client_isn+1，接下来将SYN和ACK标志位设为1，最后将
+ 这个数据包发送给客户端，这个数据包也不包含应用层的数据，服务端处于SYN_RCVD状态
+ 第三次握手：在收到服务端的数据包之后，客户端发送最后的应答包给服务器，首先tcp头部的ACK标志位设置为1
+ 然后将server_isn+1，最后将这个数据包发送给服务端，这个数据包可以携带数据给服务器，客户端处于建立状态

## 2.5 tcp三次握手的过程! （版本2）
+ 第一次握手：客户端发送SYN数据包，进入SYN_SENT状态，等待服务端确认
+ 第二次握手：收到SYN数据包以后，服务端给客户端发送ACK和SYN数据包然后进入SYN_RCVD状态
+ 第三次握手：客户端收到SYN+ACK数据包以后，发送确认包给服务器，客户端处于建立状态，服务端收到客户端的
+ ACK数据包之后，服务端也处于建立状态，完成三次握手

## 2.6 tcp四次挥手的过程!（详细版）
+ 第一次挥手：如果客户端想要关闭连接，它会发送一个tcp头部带有FIN标志位为1的数据包给服务器，进入FIN_WAIT_1状态
+ 第二次挥手：服务端收到数据包之后，会发送一个ACK应答包给客户端，然后进入CLOSED_WAIT状态，客户端接收到来自
+ 服务端的ACP应答包之后，会进入FIN_WAIT_2状态
+ 第三次挥手：在处理完数据之后，服务端会发送一个FIN数据包给客户端，然后进入LAST_ACK状态
+ 第四次挥手：在接收到服务器发送的FIN包之后，客户端会发送一个ACK包给服务器，然后进入TIME_WAIT状态，服务端在
+ 接收到ACK相应包之后，服务端进入CLOSE状态，连接关闭，客户端2MSL之后自动进入到关闭状态，客户端完成关闭连接

## 2.6 tcp四次挥手的过程!（简化版）
+ 第一次挥手：客户端发送一个FIN数据包（FIN=1）给服务端，进入FIN_WAIT_1状态，tcp规定FIN包即使它不带数据也消耗一个有序号
+ 第二次挥手：服务端收到FIN包，发送一个带有序号的确认包ACK给客户端，进入CLOSED_WAIT状态，这个时候，客户端没有数据发送
+ 但是如果服务端有数据发送，客户端一直需要接收，在接收到服务端发来的ACK确认包以后，客户端进入FIN_WAIT_2状态
+ 第三次挥手：处理完数据以后，服务器会发送一个FIN包给客户端，如果客户端处于半连接，它可能会发送更多的数据
+ 服务端进入LAST_ACK状态
+ 第四次挥手：在接收到服务端的FIN包之后，客户端发送一个ACK确认包给服务器，然后进入TIME_WAIT状态，注意tcp连接没有被释放
+ 需要2MSL之后才会进入关闭状态，服务器在收到ACK确认包以后，会进入关闭状态，可以看到服务端关闭tcp连接要早于客户端

## 2.7 TCP 为什么是三次握手，而不是两次或四次？
+ 1.两次握手无法确保序列号可靠的同步
+ 如果只是两次握手，服务器不能确定客户端是否收到了服务器初始化的序列号，如果第二次握手的
+ 数据包丢失，客户端不知道服务器的初始化序列号，因此tcp的可靠性是个问题，tcp沟通部分必须维持一个序列号，序列号是可靠传输的
+ 关键，两次握手只能确保一方的序列号被成功收到，没办法做到两方的初始化序列号都被确认收到
+ 2.防止初始化重复的历史连接
+ 客户端因为某些原因，发了两个包含不同序列号的SYN数据包，我们知道网络环境是复杂的，旧的数据包首先到达服务器
+ 如果是两次握手，服务器一收到旧的SYN数据包就会建立连接，这样会引起网络的异常
+ 如果是三次握手的模式，服务器需要返回SYN+ACK数据包，客户端可以比较响应的序列号，发送RST数据包给服务器
+ 知道正常的SYN数据包到达服务器以后，连接才会建立，所以三次握手有足够的上下文信息来判断当前连接是否是历史连接
+ 如果是两次握手连接，你无法阻止旧的连接，为什么tcp两次握手无法阻止历史连接了？
+ 我先直接说结论，主要原因是因为两次握手，所以服务器可能会建立历史连接，导致资源浪费，两次握手的情况下，服务器在收到SYN包后
+ 进入建立连接状态，意味着它可以发送数据给客户端，然而，客户端还没有进入建立连接状态，如果这是一个旧的连接，客户端会判断
+ 这个连接是一个旧的连接，发送RST消息给服务器，服务器在第一次握手后，进入建立连接状态，所以它能发送数据，但是它不知道这是一个旧的连接
+ 它只能在收到RST消息以后取消连接，可以看到，如果是使用两次握手建立tcp连接，服务器在发送数据给客户端之前，不能阻止历史连接
+ 结果服务器建立了一个历史连接，然后发送数据给客户端，浪费了服务器资源，因此要解决这个问题，最好是在服务器发送数据之前防止历史连接
+ 就是说，在连接建立之前，没有资源浪费，要达到这个功能，需要用到三次握手
+ 3.避免浪费资源
+ 如果只有两次握手，客户端的SYN数据包阻塞了网络，客户端不能收到ACK包，客户端重新发送SYN包，因为没有三次握手，服务器不知道客户端
+ 是否收到了ACK包，所以服务器只能在收到每个SYN包后立即建立连接，那会发生什么了？
+ 如果客户端的SYN包网络阻塞了，SYN包被重新发送，服务器在收到这些请求将会建立多个非法的连接，会引起资源浪费
+ 结论：在tcp连接建立时，三次握手防止了历史连接的建立，减少了双方不必要的资源浪费，帮助双方同步初始化序列号
+ _序列号可以确保包不重复，不丢失，有序的传输_
+ 不使用两次握手和四次握手的原因：
+ 两次握手：不能预防历史连接的建立，会造成双方的资源浪费，不能可靠的同步双方的序列号
+ 四次握手：三次握手理论上是最少的可靠的连接，所以不需要更多的连接次数

## 2.9 TCP 协议如何保证可靠传输
+ 1.应用数据被TCP切分成适合发送的块
+ 2.TCP给每一个要发送的包编号，接受方对包进行排序，把有序的数据发送给应用层
+ 3.检验和：TCP在它的头部和数据中维持了一个校验和，目的是检测在数据传输时校验和的变化，如果在校验片段的时候有任何错误
+ TCP就会丢弃这个片段，不会确认接受了这个片段
+ 4.TCP接收方会丢弃重复的数据
+ 5.流量控制：TCP连接的双方，各有一个缓存空间，TCP接收方允许发送方只发送数据，接收方的缓存可以接受，当接收方没有时间
+ 取处理发送方的数据时，它会通知接受方减少发送速度，防止包丢失，TCP的流量控制使用的是可变大小滑动窗口
+ 6.拥塞控制：当网络堵塞的时候，减少数据的发送
+ 7.ARQ协议：为了实现可靠的传输，基本原则是每发送完一个分组就停止发送，等待对方确认，在收到确认后，再发送下一个分组
+ 8.超时重传：在TCP发送报文之后，它设置一个计时器，等待对方确认收到了这个报文，如果不能即时确认，就会重发这个报文

## 2.10 HTTP 与HTTPS 的区别
+ 1.https协议需要申请ca证书，http不需要证书
+ 2.http超文本传输协议，传输的是明文信息，不安全，https是基于HTTP+SSL的加密传输协议，安全性更高
+ 3.http和https使用的连接方式和端口都不同，http使用80端口，https使用的是443端口
