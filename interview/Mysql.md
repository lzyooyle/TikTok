## 6.1 介绍下 MySQL 聚簇索引与非聚簇索引的区别
+ 聚簇索引的叶子节点存放的是实际数据，所有的用户记录都存放在聚簇索引的叶子节点
+ 非聚簇索引的叶子节点存放的是主键的值，不是真实的数据
+ 由于表的数据都被存放在聚簇索引的叶子节点，InnoDB存储引擎一定会表创建一个聚簇索引，由于只有一份物理数据被保存，所以只有一个聚簇索引
+ 因此，如果查询语句中使用了非聚簇索引，但是查询的数据不是主键值，通过非聚簇索引，我们可以查到主键值
+ 需要到聚簇索引获取数据值，这个过程叫做回表，也就是说需要查两棵B+树才能找到数据，然而，当查找的是主键值的时候，这个过程叫索引覆盖
## InnoDB如何选择聚簇索引
+ 如果表里有主键，就会默认选择主键所在的列，作为聚簇索引的索引键
+ 如果表里没有主键，会选择非null值的所在列，作为聚簇索引的索引键
+ 如果两者都没有，会自动创建一个隐式的自增id列，作为聚簇索引的索引键
- 通过二次索引查找数据，需要再次查询主键索引的B+树，这叫回表
- 在二级索引里面，就能查找到数据，不用回表，就称为覆盖索引
- 利用索引的前提，是索引里的key值是有序的

## 什么时候适用索引？
+ 可以区分唯一性的字段
+ where条件中用到的字段
+ Group by 和 Order by中用到的字段
- 经常给更新的数据，比如用户余额，不适合建索引，维护B+树的有序性，需要不断重建索引
- 数据量少的表，存在大量重复数据的列，经常更新数据的列，不适合建立索引

## 什么时候索引会失效？
+ 当查询条件中，出现左like %条件或者左右like %字段%的时候，索引会失效
+ 当查询条件中，对索引列做计算，函数操作，类型转换的时候，索引会失效
+ 当查询条件中or的前一个是索引列，后一个不是索引列，索引会失效
+ 当联合索引查询的时候，没有遵循最左原则，索引会失效

## B+树的特点
+ 非叶子节点，只存储索引，叶子节点存放索引和记录
+ 所有的非叶子节点的索引，都会出现在叶子节点，所有的叶子节点之间通过链表连接

## InnoDB 是如何存储数据的？
+ 数据库表中的记录的读取是以行为单位的，每一次读取就是一次IO操作，如果每次只读一行，效率太低了
+ InnoDB每次从磁盘读取数据到内存中，或从内存刷新数据到磁盘是以数据页为单位的，页大小为16KB
+ 数据页按照主键的顺序，采用单向链表连接，链表不要求磁盘上连续的空间，只要求逻辑上连续
+ 链表插入删除效率高，但检索效率低，最差的情况，需要遍历链表上所有的节点
+ 数据页中的页目录，相当于数据表中索引的作用，帮助我们快速找到记录
+ 数据页将记录分为不同的组，包括最小值，最大值，每个组的最后一条记录，就是本组的最大记录
+ 目录页中的槽，指向每个分组的最后一条记录的偏移量，最后一条记录，保存了本组所有的记录数
+ 通过二分法，先搜索槽，再通过槽，找到要找的记录数，槽相当于目录页的索引
+ InnoDB对数据分组中的记录数是有规定的：第一个分组只能有一条记录
+ 最后一个分组的记录数范围是1-8，剩余的分组记录数范围是4-8
+ 单个数据页，是通过将记录分组的方法，通过目录页中的槽号指向组中最后一条记录偏离量建立索引
+ 通过二分法，快速找到要查找的记录，当需要存储大量记录时，就需要大量的数据页
+ InnoDB需要为数据页建立索引，采用了矮胖的B+树，减少了I/O的磁盘操作次数


## MySQL的两种存储引擎 InnoDB 和 MyISAM 的区别？
+ InnoDB支持外键，支持事务，MyISAM都不支持
+ InnoDB支持行锁，支持表锁，MyISAM只支持表锁
+ InnoDB的数据库文件和索引文件，放在一起，MyISAM的数据库文件和索引文件是分开放的
+ InnoDB是聚簇索引，数据文件保存在主键索引的叶子节点上，MyISAM是非聚簇索引，叶子节点保存的是指向数据的指针
+ InnoDB不保存总行数，执行select count(*)要进行全表扫描，MyISAM用一个变量保存总行数，查询速度快
+ InnoDB的底层实现是用的B+数，只有叶子节点保存数据，非叶子节点保存索引
