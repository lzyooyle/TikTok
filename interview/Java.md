## 4.20 synchronized锁膨胀过程
+ Hotspot对象头包含两块数据：Mark Word和Class Pointer
+ Mark Word：默认保存了对象的HashCode，分代年龄和锁标志信息，Mark Word被设计为非固定的数据结构
+ 用较小的内存空间存储尽可能多的数据，在运行时存储在Mark Word里的数据会随着标志位的改变而改变
+ Class Point：一个指向对象类元数据的指针，虚拟机用来确定这个对象是哪个类的实例
+ Monitor可以理解为一个同步工具或者一个同步机制，通常被描述成一个对象，每个Java对象都有一个不可见的锁，叫做内部锁或者Monitor锁
+ Monitor是线程私有的数据结构，每个锁对象都有一个monitor
+ monitor有一个Owner字段，保存了拥有该锁线程的唯一标识，表示锁被这个线程占用
+ 目前有四众锁：无锁，偏向锁，轻量级锁，重量级锁，锁状态只能升级不能降级
+ 总结一下：偏向锁通过比较Mark Word来解决锁问题，防止执行CAS操作，轻量级锁使用了CAS操作和自旋操作解决锁的问题
+ 防止线程阻塞和唤醒影响性能，一个重量级锁会阻塞所有的线程，如果一个线程拥有了锁
+ 简洁版：
+ 偏向锁和轻量级锁是乐观锁，重量级锁是悲观锁，最初锁对象访问时是无锁对象，当第一个线程访问它时，它会偏向第一个线程
+ 这个对象持有偏向锁，第二个线程到来后，发现这个锁已经是偏向锁了，会检查拥有这把锁的线程是否还活着，如果死了
+ 会设置成无锁状态，锁会偏向新的线程，如果还活着，它会升级（膨胀）偏向锁到轻量级锁，轻量级锁认为有竞争
+ 但是只有两个线程，竞争不激烈，通常两个线程是错开的，或者在等待的时候可以通过简单的自旋获得锁
+ 但是超过了一定次数的自旋后，当第三个线程到达后，这三个线程需要竞争锁，轻量级锁会升级（膨胀）为重量级锁
+ 偏向锁和轻量级锁实在用户态维护的，重量级锁需要在内核态中切换（因为只有内核态能阻塞和唤醒线程）
## 4.19 Java 怎么实现线程安全？
+ 1.synchronized关键字：（1）确保方法或者代码块中的代码，能被原子操作，就是说同一时刻被monitor监控的代码只能被一个线程访问
+ （2）确保监控资源的可见性，线程获得monitor之后，将数据从主内存复制到工作内存中，在释放monitor之前，将数据从工作内存复制到主内存
+ （3）由原子性确保了操作的有序性，不会触发指令重排
+ 2.volatile关键字：valatile关键字确保了变量操作的可见性和有序性，volatile的目的是当一个线程更新一个volatile变量时
+ 它会通知其它线程它们工作内存中的数据失效了，它们必须重新从内存中读取数据
+ 3.atomic下的类，使用这些类声明的变量，确保了操作的原子性来确保线程安全，不像synchronized在多线程环境下，使用monitor监控锁阻塞互斥访问
+ atomic下的类是基于CAS实现的，CAS也被称为无锁操作，是一个乐观锁，原则上认为在多线程环境下，每个线程即便不加锁，也不会阻塞对共享变量的访问
+ 线程也不会被挂起，如果有冲突，会循环比较，直到没有冲突
+ 4.使用Lock接口下的ReentrantLock实现类，它也是一种悲观锁，它是一种手动锁，使用更加灵活，然而你必须记得使用完要释放锁，否则可能会出现死锁
## 4.18 Java 重载与重写是什么？有什么区别？
+ 重载是一种使用一个类管理不同类型的数据的联合，重载的本质是多个同名的方法名，有不同类型的参数，返回值随意，不以返回值作为区分标准
+ 同时存在一个类中，是一种多态的体现，一个方法可以通过不同类型和个数的参数进行调用
+ 重写本质上是对父类方法的重新定义，如果方法定义在子类中，有着和父类相同的参数，这个方法将被重写，但是子类方法的可访问修改权限
+ 不能小于父类，如果子类有着和父类一样的的方法名，返回值，参数，这个新方法将会覆盖已存在的方法，如果你想使用父类中的方法，你可以使用super关键字
+ 重载的规则：必须参数的类型或个数不同，可以有不同的返回类型，可以有不同的访问修饰符，可以抛出不同的异常类型
+ 重写的规则：参数必须相同，返回类型必须相同，访问修饰符：子类必须大于等于父类，子类抛出的异常不能比父类抛出的异常更宽泛
+ 重载和重写是Java中不同的多态体现，重写是父类和子类之间多态的体现，出现在运行期（动态多态实现动态绑定）
+ 重载是一个类中的多态，出现在编译器（静态多态实现静态绑定）
+ java构造方法可以被重写或重载吗：方法重写是在子类中重写父类的方法，重写方法的名字是不能被改变的，类的构造器的名字必须和类名相同
+ 假如父类构造器可以被子类重写，那么子类的名字必须和父类一直，所以Java中构造器是不能被重写的，但是可以被重载
## 4.17 volatile和synchronized的区别
+ 1.volatile本质上是告诉jvm，工作内存中的值是不确定的，需要从主内存中读取，synchronized锁定了变量
+ 只能是当前线程可以访问，其它线程被阻塞了
+ 2.volatile只能用在变量级别，synchronized可以用在变量，方法，类级别上
+ 3.volatile改变变量只能获得可见性，但是不能保证原子性，synchronized保证修改的可见性和原子性
+ 4.volatile不会阻塞线程，synchronized会阻塞线程
## 4.16 ArrayList和LinkedList的区别
+ 1.ArrayList是基于数组实现的，LinkedList是基于双向链表实现的
+ 2.对于随机查询操作，ArrayList要优于LinkedList
+ 3.对于插入和删除操作，LinkedList要由于ArrayList
+ 4.LinkedList要比ArrayList占用更多的内存，因为LinkedList的节点不仅要存储数据，还要存储两个引用，一个指向前面的元素，一个指向后面的元素
## 4.15 乐观锁和悲观锁的区别
+ 对多线程操作相同的数据，悲观锁认为使用线程的时候，一定有另一个线程修改数据，所以当获得数据的时候首先把数据锁住
+ 确保数据不被其它线程修改，在Java中，synchronized关键字和Lock类的实现都是悲观锁
+ 乐观锁认为它使用数据的时候，不会有其它线程修改数据，所以它不会加锁，只有在要更新数据的时候，才会去判断之前有没有
+ 其它线程修改数据，如果数据没有被修改，当前线程修改数据成功，如果数据已经被其它线程修改了，具体操作是不同的
+ 取决于实现方式（报错或者自动重试）
+ 乐观锁在java中，是通过无锁编程来获得的，大多数使用了CAS算法，java原子类递增操作就是依靠CAS
## 4.14 双亲委派机制
+ 双亲委派机制：如果类加载器需要加载一个类，它首先会将这个请求，派发给它的父类加载器去完成，每一层都是这样，一直递归到顶层
+ 当父类加载器无法完成这个请求时，子类才会尝试加载
+ 双亲委派机制的作用，防止了类重复加载，确保了安全，防止了Java的核心jar包被本地覆盖替换
+ 什么是双亲委派机制？类加载器被会分为，启动类加载器，扩展类加载器，应用类加载器，自定义加载器，当一个类加载器收到一个需要加载类
+ 的请求时，它不会自己加载这个类，而是交给父加载器加载，如果父加载器没有找到这个类就不加载，然后才会自己加载
+ 父类和子类加载器，是继承关系吗？不是继承关系，我们使用了组合方式，重写了类加载器
+ 我们能破坏双亲委派机制码？怎么破坏？可以，通过自定义类加载器，重写loadClass方法
+ 为什么JDBC需要打破双亲委派机制？JDBC通过引入ThreadContextClassLoader来打破双亲委派机制
+ 为什么Tomacat需要打破双亲委派机制？Tomacat通过为每个web容器引入WebAppClassLoader来提供独隔离机制
## 4.13 线程死锁怎么产生的以及如何避免
+ 死锁是一个现象：两个或两个以上的线程，在执行的过程中，由于竞争资源或相互沟通，被阻塞了，没有外界的干预，它们将无法继续执行
+ 系统处于死锁状态，这些线程将会一直相互等待，这种现象称之为死锁
+ 多个线程在同一时刻阻塞了，它们中的一个或所有的线程，在等待所需要的资源被释放，线程被无限阻塞，不可能正常终止
+ 对于死锁的发生有四个必要条件：
+ 1.相互排斥：一个资源在某一个时刻只能被一个线程使用
+ 2.请求与保持：当线程请求的资源已经被占用，引起了线程阻塞，这个资源的持有者不但不用释放资源，还可以继续请求更多的资源
+ 3.不能被剥夺：线程在使用完它已经获得的资源前，不能被其它线程强行剥夺使用，只有在使用它们的资源后，才能被释放
+ 4.循环等待：当死锁出现的时候，所有等待的线程必须是一个环（和死循环类似），引起永久性阻塞
+ 如何避免死锁：
+ 1.破坏互斥条件：没有办法破坏这个条件，因为我们使用锁就是为了让他们互相排斥
+ 2.破坏请求和保持条件：一次性申请所有需要的资源
+ 3.破坏不能被剥夺条件：如果线程占用了部分资源，不能再申请其它资源，可以让它主动释放已占用的资源
+ 4.破坏循环等待的条件：有序预防需要的资源，按照一定的顺序申请资源，按照相反的顺序释放资源
## 4.12 Java线程的六种状态以及切换
+ 1.初始化：创建一个新的线程对象，此时start()方法还没有被调用
+ 2.运行态：java一般使用运行来概括就绪态和运行态，线程对象被创建后，另一个线程，比如主线程会调用start()方法，这个线程在可运行的线程池中
+ 等待被线程调度器选择，获得使用CPU，这时处于就绪状态，一个就绪的线程当获得CPU时间片的时候，会变成运行态
+ 3.阻塞态：表示线程被锁阻塞了
+ 4.等待态：进入等待状态的线程，需要等待另一个线程，做出一些特定的操作（唤醒或中断）
+ 5.超时等待：不像等待状态，这个状态可以在指定的时间后，自动返回
+ 6.结束状态：表示线程已完成执行
## 4.11 hashCode与equals方法之间的关系
+ equals() 与 == 的区别是什么:
+ ==判断两个对象的地址是否相同，也就是说两个对象是否是同一个对象
+ equals()也是用来判断两个对象是否相等，然而，一般使用有两种情况：
+ 1.情况1：这个类没有重写equals()方法，比较一个类中的两个对象，equals()等价于比较两个对象的==
+ 2.情况2：这个类重写了equals()方法，一般来说，我们重写了equals方法比较两个对象的内容是否相等，如果内容相等，返回true，也就是两个对象被认为相等
+ hashCode方法用来获取hash码，用来确定对象在hash table中的索引位置
+ 为什么要有hashCode：
+ 当一个对象被加入到HashSet中，会计算出它的hash值，确定这个对象被添加的位置，检查这个位置是否有值，如果没有值，就会直接添加它
+ 如果有对象，就会调用equals()方法检查这两个对象是否相等，如果它们相等，这个对象就不会被保存，如果它们不同，这个对象会被加到另外一个位置上
+ 如果两个对象相等，它们的hashCode值一定相等，如果两个对象的hash值相等，它们不一定相等，减少了比较的次数，提高了执行效率
## 4.10 ConcurrentHashMap 和 Hashtable 的区别
+ 1.出现版本不同：HashTable自从jdk1.0和jdk1.2就已经实现map接口了，作为集合的框架，ConcurrentHashMap直到jdk1.5才被引进，因为它们的时代不同，后出现的
+ 要比前面出现的做了优化，所以它们的实现和性能上都有很大的不同
+ 2.线程安全的实现方式不同：原则上说，HashTable的并发安全的获得，是通过synchronized关键字实现的，HashTable几乎每个方法都加了synchronized关键字
+ 因此HashTable是线程安全的，ConcurrentHashMap实现原理和HashTable有本质得不同，它得线程安全是使用了CAS+synchronized+Node，和HashTable完全使用
+ synchronied完全不同
+ 3.性能不同：因为它们实现线程安全得方式不同，它们得性能也不同，当线程增加得时候，HashTable得性能会急剧下降，因为每一次修改需要锁住整个对象
+ 其它线程不能在此期间操作，还会带来额外得上下文切换，所以吞吐量不如单线程好，对于ConcurrentHashMap，锁只锁住一部分，不是全部
+ 所以多线程下得吞吐量，通常要好于单线程，换句话说ConcurrentHashMap比HashTable更高效
+ 4.在迭代期间修改得不同：HashTable（包括HashMap）不允许在迭代得时候，修改内容，否则会抛出ConcurrentModificationException，它得规则是检测modCount变量
+ 迭代器中next()方法，首先检查modCount是否和expectedModCount相等，expectedModCount是随着迭代器产生而产生得，不会改变，表示HashTable中被改变了几次，
+ modCount在每次修改得时候会被改变，修改包括addEntry()，remove()，rehash()，如果我们在迭代HashTable得时候进行修改操作，它也会影响modCount
+ 结果下一次迭代得时候，会被察觉，会发现modCount不等于expectedModCount会抛出ConcurrentModificationException
+ 所以对于HashTable来说，它不允许在迭代时候修改内容，而CouncurrentHashMap即使在迭代得时候修改内容，也不会抛出异常，如果我们有一个并发得场景
+ 使用ConcurrentHashMap更合适，HashTable不再推荐使用
## 4.9 JVM内存结构
+ 堆：线程共享的，所有的对象实例和数组都分配在堆区，收集器主要管理的对象
+ 方法区：线程共享的，保存了类信息，常量，静态变量，和即时编译的代码
+ 方法栈：线程私有的，保存了局部变量表，操作栈，动态连接，方法出口，对象指针
+ 本地方法栈：线程私有，为VMS使用的本地方法提供服务，举个例子，当使用写在c或C++的服务接口时，代码会运行在这个区域
+ 程序计数器：线程私有，一些文章里翻译成PC注册器，是一样的东西，它可以看作当前线程正在执行的字节码的行号，指向下一条要执行的指令地址
## 4.8 JVM常见的几种GC算法
+ 有两种常见的分析对象存活的算法：引用计数算法，可达性分析算法
+ 1.引用计数算法：给对象添加一个计数器，如果对象被引用就+1，如果对象被释放就-1，当计数器为0的时候，说明这个对象没有被引用，需要被回收
+ 2.可达性分析算法：设置一些根类型的对象，如果根对象无法达到指定的对象，这个对象是可以被回收的
+ 常见GC算法：
+ 1.复制算法：内存被划分为两个相等的区域，当一个区域使用完后，幸存的对象会被拷贝到另一个区域，优点：实现简单，效率高，没有内存碎片，缺点：内存利用率低
+ 2.标记清除算法：首先将可回收的对象标记出来，标记完之后，开始清理，优点：效率高，内存利用率高，缺点：会产生内存碎片
+ 3.标记整理算法：首先标记出要清除的对象，标注完成后，开始清理，将幸存的对象往左移动，优点：没有内存碎片，缺点：低效
+ 4.分代收集算法：没有什么新的思想，根据对象的生存周期，把内存划分为几块，一般来说，java堆被划分成年轻代和老年代，所以你可以根据每个代的特性
+ 选择合适的垃圾收集算法，在新生代中，可以看到大量的对象死去，每一次垃圾回收的时候，只有少数的幸存者对象存活，所以选择复制算法，只需要复制少数的对象
+ 然而在老年代，因为对象的存活率较高，没有额外的空间分配，标记清除和标记整理算法，可以被用来回收
+ 垃圾收集器：
+ 新生代：
+ 1.SerialNew垃圾回收器：最早的最基础的回收期，单线层垃圾回收器，当回收垃圾的时候需要STW
+ 2.ParNew垃圾回收器：SerialNew的多线程版本，在单核cpu的场景下，效率没有SerialNew高，它现在只工作在cms上
+ 3.Parallel Scavenge垃圾回收器：一个多线程垃圾回收器，和ParNew类似，它也采用复制算法，但是不像ParNew，Parallel Scavenge关注高吞吐量
+ 老年代：
+ 1.SerialOld垃圾回收器：较早版本的垃圾回收器，一个单线程垃圾回收期，使用标记整理算法
+ 2.Parallel Old垃圾回收算法：一个较早版本的并行收集，一个多线程收集器，使用标记整理算法
+ 3.CMS收集器：并发的标记交换，目标是为了获得低停顿，实现基于标记清除算法
+ 4.G1垃圾回收器：将堆划分为多个大小相等的区域，新生代和老年代不再物理隔离，在多核cpu和大内存的场景下，提供更高的性能，新生代使用复制算法，老年代使用标记压缩算法
## 4.7 String、StringBuffer和StringBuilder的区别
+ 1.String的长度不可变，StringBuffer和StringBuilder的长度是可变的
+ 2.StringBuilder是线程不安全的，StringBuffer是线程安全的
## 4.6 sleep和wait的区别
+ 1.sleep方法是Thread类的静态方法，wait方法是Object类的一个方法
+ 2.sleep方法在指定的时间内，会造成当前线程暂停执行，释放CPU交给另一个线程，但是它的监控状态会保留，当指定的时间结束后，它会自动
+ 回到运行状态，sleep方法被调用后，线程不会释放对象锁，当wait方法被调用，线程会丢弃锁并挂起，只有在notify方法被调用后
+ 线程才会重新获得锁资源
+ 3.sleep方法可能会抛出异常，需要异常处理，wait方法不需要异常处理
+ 4.sleep方法可以写在任何地方，wait方法只能被使用在同步方法或者同步代码块中

## 4.5 可重入锁和非可重入锁的区别
+ 可重入锁也被称为递归锁，意思是相同的线程如果在外部方法中，已经获得了锁，内部方法就会自动获得锁（前提是锁对象的只能是相同的对象或类）
+ 不会因为之前，它已经获得的过锁，但还没有释放，产生阻塞，可重入锁的一个优点是防止了死锁
+ 非可重入锁和可重入锁相反，是非递归锁，如果递归就会产生死锁

## 4.4 线程池的七个参数，线程池的好处
+ 核心线程数量，线程池中最大线程数量，空闲线程存活时间，空闲线程存活时间计量单位，工作队列，线程工厂，拒绝策略
+ 拒绝策略：中止策略报异常，将任务交给任务调用线程执行，直接丢弃策略，丢弃队列中等待时间最长的线程
+ 线程池的好处：
+ 1.减少了资源的开销，减少了创建线程和销毁线程的开销
+ 2.提高了响应速度：当一个人任务到达时，它可以被立即执行，而不需要等待线程的创建
+ 3.提高了线程的可管理性：线程是稀缺资源，如果无节制的创建，它将会消费系统资源，也会降低系统的稳定性，线程池可以被统一分配和监控
+ java中有哪些常用的线程池：
+ 1.newFixedThreadPool：创建一个固定大小的的线程池，每次提交一个任务，创建一个线程，直到线程数达到线程池的最大数
+ 2.newCachedThreadPool：创建一个可缓存的线程池，没有大小限制，线程池的大小取决于，操作系统能创建的最大线程数
+ 3.newScheduledThreadPool：创建一个无限大小的线程池，支持定时和周期任务执行的需求
+ 4.newSingleThreadExecutor：创建一个单线程的线程池，这个线程池支持定时和周期性的任务执行的需求
+ 任务调度流程：提交任务后，首先判断线程池是否执行，如果没有执行直接拒绝执行，如果已经执行了，就判断线程数是否小于核心线程数
+ 如果小于就交给工作队列执行，如果大于，就判断阻塞队列是否已满，如果没有，就像线程放入阻塞的队列，等待工作队列调用执行
+ 如果满了，就判断线程数是否大于最大线程队列，如果大于就拒绝执行，如果小于就交给工作队列执行


## 4.3 反射的原理，有什么应用
+ 在java虚拟机加载类后，它会在堆内存的方法区中，生成一个Class类型的对象（每个类只有一个class类对象），包含了完整的类结构信息，我们通过这个对象看到了这个类的结构
+ 这个对象像一面镜子，通过它你可以看到这个类的结构，我们称之为反射

## 自旋锁
自旋锁采用忙循环，synchronized涉及到线程的用户态和内核态的切换，浪费时间，资源，影响效率。wait，sleep，yield会放弃CPU的控制权，而自旋锁不会。

## synchronized锁升级的原理
偏向锁顾名思义会偏向于第一个访问他的线程，设置字段Threadid，如果线程自带的id和偏向锁自带的id不一致，则升级为轻量级锁，轻量级锁采用自旋的方式获取锁，在获取一定的次数失败后，会升级为重量级锁。

## CAS会产生什么问题
+ CAS：比较和交换，是一种无锁算法，在多个线程之间不使用锁，实现变量同步（没有线程阻塞），java.util.concurrent包的原子类，通过CAS实现乐观锁
### 1. ABA问题：
one线程从V地址取出值A，two线程也从V地址取出值A，改成值B，再改成值A，one线程通过CAS发现值A没变，这个过程是存在潜在问题的。
### 2. 资源消耗过大：
在资源竞争激烈的场景下，CAS可能会频繁的的发生，对CPU资源是一种极大的浪费。（自旋锁不会放弃对CPU的控制）
### 3. 只能保证一个共享变量的原子操作：
CAS是无法保证，对多个共享变量的原子操作的，这个时候，就可以用到锁。

## 进程的创建
+ 操作系统允许一个进程创建另一个进程，允许子进程继承父进程拥有的资源
+ 首先会申请一个空白的PCB（进程控制块），向PCB中写于进程的唯一标识
+ 为进程分配内存资源，将PCB插入就绪队列，等待操作系统的调度运行

## 终止进程
+ 终止进程有三种方式，正常结束，异常结束，外界干预（kill -9）
+ 当子进程终止时，其从父进程处继承的资源，应该还给父进程
+ 当父进程终止时，其子进程就成了孤儿进程，会被1号进程收养，并由1号进程收集其状态信息
+ 查找要终止进程的PCB，如果该进程处于执行状态，则立即终止该进程的执行
+ 将PCB资源分配给其他进程，如果该进程还有子进程，则将子进程交给1号进程接管
+ 将该进程所拥有的全部资源还给操作系统，将该进程从所在的队列删除

## 阻塞进程
+ 找到要阻塞进程标识符对应的PCB，如果该进程处于执行状态，则保护现场
+ 将该进程的状态转为阻塞状态，停止运行，将PCB插入到阻塞队列

## 唤醒进程
+ 在阻塞队列中找到相应进程的PCB，将PCB移出阻塞队列
+ 将该进程的状态改为就绪状态，将PCB插入就绪队列，等待调度程序调度

## 4.1 HashMap底层原理
+ 1.jdk1.7采用数组+链表的方式，采用头插法，jdk1.8采用数组+链表+红黑树的方式，采用尾插法
+ 2.当元素个数达到容量的0.75，就会扩容为原来的2倍，当数组容量达到64，链表长度大于等于8，链表会转化为树，当链表的长度小于6，树会转成链表
+ map.put(k,v)方法的原理：先将k和v压缩到Node对象中，然后调用hashcode方法得到hash值，通过hash算法将hash值转换为数组下标
+ 如果下标位置没有元素，这个节点会添加到那个位置，如果存在链表，就调用equals方法，将k的值和链表上的每个节点，进行比较
+ 如果返回false，新节点会被插入到链表的尾部，如果返回true，这个节点上的值将会被覆盖
+ map.get(k)方法的原理：首先调用hashcode方法得到hash值，然后通过hash算法得到数组中下标的位置，快速定位到位置，如果没有元素，返回null
+ 快速定位位置，如果该位置上没有元素，返回null，如果有一个单向链表，就用参数k的值和单向链表上的每个节点进行比较
+ 如果返回false，get方法返回null，如果有一个节点的值符合，返回true

## 4.2 JVM类加载过程!
+ 类的加载机制：jvm从class文件加载数据到内存，然后对数据进行验证，准备，解析，初始化，最后形成可以被jvm直接使用的Java类型
+ 这个过程叫做类加载机制
+ JVM类加载机制可以划分为5个部分：加载，验证，准备，解析和初始化，让我们看一下这五个部分的每一块：
+ 1.加载
+ 加载阶段会生成一个代表这个类的java.lang.class对象，作为方法区中，关于这个类的各种数据的入口
+ 2.验证
+ 这个阶段的目的，是为了确保这个类文件中的字节流信息，达到虚拟机的要求，不会危害虚拟机的安全
+ 3.准备
+ 准备阶段会正式为这些类变量，分配内存空间和设立初始化值，在方法区为这些变量分配其使用的空间
+ 4.解析
+ 这个阶段是关于，虚拟机将常量池中的符号引用替换为直接引用的过程
+ 5.初始化
+ 初始化阶段，除了在加载阶段你可以自定义加载器，其它情况下JVM将发挥主导作用，在初始化阶段，定义在类文件中的Java程序代码将会被真正执行
