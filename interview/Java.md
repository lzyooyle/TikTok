## 4.6 sleep和wait的区别
+ 1.sleep方法是Thread类的静态方法，wait方法是Object类的一个成员
+ 2.sleep方法在指定的时间内，会造成当前线程暂停执行，释放CPU交给另一个线程，但是它的监控状态会保留，当指定的时间结束后，它会自动
+ 回到运行状态，sleep方法被调用后，线程不会释放对象锁，当wait方法被调用，线程会丢弃锁，进入对象等待锁定池，只有在notify方法被调用后
+ 线程才会进入对象等待锁定池的准备状态

## 4.5 可重入锁和非可重入锁的区别
+ 可重入锁也被称为递归锁，意思是相同的线程如果在外部方法中，已经获得了锁，内部方法就会自动获得锁（前提是锁对象的只能是相同的对象或类）
+ 不会因为之前，它已经获得的过锁，但还没有释放，产生阻塞，可重入锁的一个优点是防止了死锁
+ 非可重入锁和可重入锁相反，是非递归锁，如果递归就会产生死锁

## 4.4 线程池的七个参数，线程池的好处
+ 核心线程数量，线程池中最大线程数量，空闲线程存活时间，空闲线程存活时间计量单位，工作队列，线程工厂，拒绝策略
+ 拒绝策略：中止策略报异常，将任务交给任务调用线程执行，直接丢弃策略，丢弃队列中等待时间最长的线程
+ 线程池的好处：
+ 1.减少了资源的开销，减少了创建线程和销毁线程的开销
+ 2.提高了响应速度：当一个人任务到达时，它可以被立即执行，而不需要等待线程的创建
+ 3.提高了线程的可管理性：线程是稀缺资源，如果无节制的创建，它将会消费系统资源，也会降低系统的稳定性，线程池可以被同一分配和监控
+ java中有哪些常用的线程池：
+ 1.newFixedThreadPool：创建一个固定大小的的线程池，每次提交一个任务，创建一个线程，直到线程数达到线程池的最大数
+ 2.newCachedThreadPool：创建一个可缓存的线程池，没有大小限制，线程池的大小取决于，操作系统能创建的最大线程数
+ 3.newScheduledThreadPool：创建一个无限大小的线程池，支持定时和周期任务执行的需求
+ 4.newSingleThreadExecutor：创建一个单线程的线程池，这个线程池支持定时和周期性的任务执行的需求


## 4.3 反射的原理，有什么应用
+ 在java虚拟机加载类后，它会在堆内存的方法区中，生成一个Class类型的对象（每个类只有一个class类对象），包含了完整的类结构信息，我们通过这个对象看到了这个类的结构
+ 这个对象像一面镜子，通过它你可以看到这个类的结构，我们称之为反射

## 自旋锁
自旋锁采用忙循环，synchronized涉及到线程的用户态和内核态的切换，浪费时间，资源，影响效率。wait，sleep，yield会放弃CPU的控制权，而自旋锁不会。

## synchronized锁升级的原理
偏向锁顾名思义会偏向于第一个访问他的线程，设置字段Threadid，如果线程自带的id和偏向锁自带的id不一致，则升级为轻量级锁，轻量级锁采用自旋的方式获取锁，在获取一定的次数失败后，会升级为重量级锁。

## CAS会产生什么问题
### 1. ABA问题：
one线程从V地址取出值A，two线程也从V地址取出值A，改成值B，再改成值A，one线程通过CAS发现值A没变，这个过程是存在潜在问题的。
### 2. 资源消耗过大：
在资源竞争激烈的场景下，CAS可能会频繁的的发生，对CPU资源是一种极大的浪费。（自旋锁不会放弃对CPU的控制）
### 3. 只能保证一个共享变量的原子操作：
CAS是无法保证，对多个共享变量的原子操作的，这个时候，就可以用到锁。

## 进程的创建
+ 操作系统允许一个进程创建另一个进程，允许子进程继承父进程拥有的资源
+ 首先会申请一个空白的PCB（进程控制块），向PCB中写于进程的唯一标识
+ 为进程分配内存资源，将PCB插入就绪队列，等待操作系统的调度运行

## 终止进程
+ 终止进程有三种方式，正常结束，异常结束，外界干预（kill -9）
+ 当子进程终止时，其从父进程处继承的资源，应该还给父进程
+ 当父进程终止时，其子进程就成了孤儿进程，会被1号进程收养，并由1号进程收集其状态信息
+ 查找要终止进程的PCB，如果该进程处于执行状态，则立即终止该进程的执行
+ 将PCB资源分配给其他进程，如果该进程还有子进程，则将子进程交给1号进程接管
+ 将该进程所拥有的全部资源还给操作系统，将该进程从所在的队列删除

## 阻塞进程
+ 找到要阻塞进程标识符对应的PCB，如果该进程处于执行状态，则保护现场
+ 将该进程的状态转为阻塞状态，停止运行，将PCB插入到阻塞队列

## 唤醒进程
+ 在阻塞队列中找到相应进程的PCB，将PCB移出阻塞队列
+ 将该进程的状态改为就绪状态，将PCB插入就绪队列，等待调度程序调度

## 4.1 HashMap底层原理
+ 1.jdk1.7采用数组+链表的方式，采用头插法，jdk1.8采用数组+链表+红黑树的方式，采用尾插法
+ 2.当元素个数达到容量的0.75，就会扩容为原来的2倍，当数组容量达到64，链表长度大于等于8，链表会转化为树，当链表的长度小于6，树会转成链表
+ map.put(k,v)方法的原理：先将k和v压缩到Node对象中，然后调用hashcode方法得到hash值，通过hash算法将hash值转换为数组下标
+ 如果下标位置没有元素，这个节点会添加到那个位置，如果存在链表，就调用equals方法，将k的值和链表上的每个节点，进行比较
+ 如果返回false，新节点会被插入到链表的尾部，如果返回true，这个节点上的值将会被覆盖
+ map.get(k)方法的原理：首先调用hashcode方法得到hash值，然后通过hash算法得到数组中下标的位置，快速定位到位置，如果没有元素，返回null
+ 快速定位位置，如果该位置上没有元素，返回null，如果有一个单向链表，就用参数k的值和单向链表上的每个节点进行比较
+ 如果返回false，get方法返回null，如果有一个节点的值符合，返回true

## 4.2 JVM类加载过程!
+ JVM类加载机制可以划分为5个部分：加载，验证，准备，解析和初始化，让我们看一下这五个部分的每一块：
+ 1.加载
+ 加载阶段会生成一个代表这个类的java.lang.class对象，作为方法区中，关于这个类的各种数据的入口
+ 2.验证
+ 这个阶段的目的，是为了确保这个类文件中的字节流信息，达到虚拟机的要求，不会危害虚拟机的安全
+ 3.准备
+ 准备阶段会正式为这些类变量，分配内存空间和设立初始化值，在方法区为这些变量分配其使用的空间
+ 4.解析
+ 这个阶段是关于，虚拟机将常量池中的符号引用替换为直接引用的过程
+ 5.初始化
+ 初始化阶段，除了在加载阶段你可以自定义加载器，其它情况下JVM将发挥主导作用，在初始化阶段，定义在类文件中的Java程序代码将会被真正执行
