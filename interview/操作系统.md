## 1.3 Linux常见命令
+ 
## 1.2 操作系统中的进程调度策略有哪几种
+ 1.先来先服务算法：选择就绪队列中的第一个进程运行，当前进程运行完成或阻塞的时候，会选择下一个进程运行，对长作业有利，对短作业不利
+ 适合CPU繁忙的操作系统，不适合IO操作繁忙的系统
+ 2.短作业优先算法：选择运行中最短的作业进程运行，可以提高系统的吞吐量，但是不适合长作业，如果有许多短作业，长作业将会在很长时间内，不会被执行
+ 3.最大响应比调度算法：公式：(等待时间+需要服务时间)/需要服务时间，当等待时间相同，需要服务时间更短的，有更高的响应比，适合短作业操作
+ 需要相同的服务时间，等待时间更长的，响应比更高，适合长作业操作，这是一个理想算法，但是因为程序需要服务，时间不可预测，所以这个算法没有用在实际的程序中
+ 4.时间片轮转算法：为每个进程设置一个相同的时间片，如果时间片用完了，进程会被挂起，会从就绪队列中，选一个新的进程运行，如果进程在时间片内完成了或阻塞了
+ 调度器回迅速切换，选择一个新的进程执行，短作业时间片过多，会引起过度上下文切换，减少CPU的执行效率，如果时间片过长，短作业响应时间会减少，正常的设置在20-50ms
+ 5.最高优先级调度算法：对于多个用户，你想从读取队列中，选择更高优先级的进程运行，有两种类型的优先级，静态优先：一个进程被创建的时候，优先级就决定了
+ 动态优先：动态优先级适合运行中的进程，当进程的运行时间增加，它的优先级会减少，当前进程完成的时候，会选择更高优先权的进程，当一个进程在运行的时候
+ 如果有出现了一个更高优先级的进程，当前线程会被挂起，更高优先级的进程会被选择运行
+ 6.多级反馈队列调度算法：这个算法合并了时间片轮转算法和最高优先级调度算法，进程被划分为多个队列，每个队列按顺序被分配优先级
+ 高优先级的进程，时间片很短，当一个队列中出现一个高优先级的进程时，队列中正在执行的进程会停止执行，让更高优先级的进程执行
+ 最新插入的进程，会被放在队列的尾部，等待调度器执行，如果进程在指定的时间片里，没有执行完，它将会被插入到下一个队列的尾部
+ 直到执行完成，如果高优先级的队列空了，低优先级的队列将会被执行，如果有一个进程插入到高优先级的队列，当前线程将会停止执行
+ 这个进程将会被插入到原来队列的尾部，转而执行高优先级的进程，对于短作业，队列很可能会一开始就快速执行，对于长作业会移动到
+ 低优先级的队列中执行，虽然长作业的等待时间很长，但是执行时间也很长，这个算法有一个更好的响应率
## 寄存器和程序计数器
+ 寄存器是CPU内部的速度极快的缓存
+ 程序计数器是用来记录正在执行的指令的位置，或者即将执行的下一条指令的位置

## CPU的上下文切换
+ 先将上一个任务的上下文保存起来，再加载新任务的上下文到寄存器和程序计数器
+ 然后跳转到程序计数器指定的新任务的位置，运行新任务
+ 当上个任务再次分配给CPU运行时，CPU会加载上次保存的上下文
+ 这样上个任务的状态不会受到影响，看起来任务没有被中断，是在连续运行
+ 任务包括了进程，线程，中断，所以CPU上下文切换包括了进程上下文切换，线程上下文切换，中断上下文切换
+ 进程是由内核调度和管理的，所以进程的切换，只能发生在内核态

## 进程上下文切换的场景
+ 进程的时间片用尽，状态会被改为就绪态，CPU会从就绪队列选择一个进程运行
+ 内存不足的时候，进程会被挂起，系统会调度其他的进程运行
+ 有高优先级的进程需要运行时，系统会挂起当前的低优先级进程

## 线程的上下文切换
+ 为什么不用多个进程，保证进程之间的数据通信是一件很复杂的事情
+ 进程的开销很大，涉及资源分配，建立PCD，资源回收，撤下PCD，进程切换保存状态信息
+ 线程之间可以共享相同的空间地址，可以并发执行
+ 线程是进程的一条执行流程，可以共享进程的资源，但各自具有独立的栈和寄存器
+ 进程是资源分配的单位，线程是CPU调度的单位，减少了进程并发执行的开销
+ 从空间角度来看，进程间的切换，需要CPU保存上一个任务的上下文，加载新任务的上下文
+ 通过程序计数器获取新任务的地址，指向新的位置，执行新任务
+ 线程是共享空间地址的，不需要使用程序计数器指向新的地址
+ 从时间角度来看，进程是内核调度管理的，进程切换只能发生在内核态
+ 不仅包含了进程的虚拟内存，栈，共享变量等，还需要切换内核态的堆栈，寄存器
+ 线程是共享进程资源的，只需要切换自己的栈和寄存器即可
+ 用户线程是在用户态实现的，是多对一的关系，内核线程是在内核态实现的，是一对一的关系
+ 轻量级线程是在内核中支持用户线程，是多对多的关系
+ 每个进程都要有一个线程控制块（CTB）列表，用来记录各个线程的状态（栈，寄存器）
+ TCB由用户线程库函数来维护，也负责线程的切换，无需内核态和用户态的切换

## 用户线程的缺点
+ 由于系统不参与用户线程的调用，所以当一个用户线程发生阻塞的时候，这个进程中所有用户线程都会阻塞
+ 当一个用户线程开始运行后，除非它自己主动交出CPU的控制权，否则该进程中的其他线程无法执行
+ 用户线程没有打断当前正在执行线程的特权，只有操作系统才有，用户线程又不归操作系统管理

## 调度算法
+ 非抢占式调度算法：操作系统从就绪队列中选一个进程执行，在该进程没有被阻塞或者结束之前
+ 不会选择其他进程执行，也就是说不会去理会时钟中断这个事情
+ 抢占式调度算法：调度程序挑选一个进程，让其在某段时间内运行，如果运行时间结束
+ 程序还没有执行完，则会将其挂起，然后从就绪队列中，挑选一个进程运行，这种算法也称为时间片机制

## 调度原则
+ CPU利用率要高，如果进程在执行过程中，发生IO事件，进程需要等待，CPU会出现空闲状态
+ 系统吞吐量要高（单位时间执行的进程数量），如果执行某个任务占用时间较长，会影响系统吞吐量，需要衡量长任务和短任务
+ 周转时间（等待时间+运行时间+阻塞时间），如果等待时间长，运行时间短，则周转时间长，不是我们希望的
+ 等待时间（在就绪队列的时间，不是阻塞时间），等待时间不宜过长，这样可以让CPU更快的执行该程序
+ 响应时间，对于交互性比较强的应用，响应时间越短越好，可以提高用户体验

## 1.先来先服务调度算法
+ 选择就绪队列中第一个进程运行，在其运行完成或阻塞后，运行下一个进程，对于长作业有利，对于短作业不利
+ 长作业运行的时间长，短作业等待的时间就长了，适合CPU繁忙型作业系统，不适合IO繁忙型作业系统

## 2.最短作业优先调度算法
+ 会优选选择运行时间最短的进程运行，有利于提高系统吞吐量，对长作业不利，如果短作业过多，长作业长时间得不到执行

## 3.最高响应比调度算法
+ 公式：等待时间+要求服务时间/要求服务时间，等待时间相同，要求服务时间越短，响应比越高，适合于短作业
+ 要求服务时间相同，等待时间越长，响应比越高，适合长作业，这是一个最理想的算法，但由于程序要求服务
+ 时间不可预知，所以实际程序中不使用该算法

## 4.时间片轮转法
+ 为每个进程设置相同的时间片，如果时间片执行完，进程还没有结束，会将其挂起，从就绪队列中选择新的进程执行
+ 如果在时间片内，进程执行完或被阻塞，调度程序会立即切换，选择新进程执行，时间片太短，会造成过多的上下文切换
+ 降低CPU的执行效率，时间片设置的太长，会降低短作业的响应时间，正常设置为20-50ms

## 5.最高优先级调度算法
+ 对于多用户来说，希望从就绪队列中，选择最高优先级的进程运行
+ 优先级分为两种，静态优先级：在创建进程的时候就确定了优先级；动态优先级：在进程运行的过程中，动态的调整优先级
+ 进程的运行时间增加，降低其优先级，等待时间变长，提高其优先级
+ 非抢占式算法：在进程运行的时候，如果出现优先级更高的进程不用管，继续运行当前进程结束后，再选择优先级高的进程
+ 抢占式算法：在进程运行的时候，如果出现优先级高的进程，则会将当前进程挂起，优先选择更高优先级的进程运行

## 6.多级反馈队列调度算法
+ 这个算法是时间片轮转算法和最高优先级调度算法的结合，将进程分为多个队列，每个队列按照优先级顺序排列
+ 优先级越高时间片越短，当有进程插入到优先级高的队列的时候，会停止当前执行进程，转而执行优先级高的队列
+ 新插入的进程会被安排在队列的末尾，等待调度执行，如果在规定的时间片内，没有执行完，会被插入到
+ 下一级队列的末尾，以此类推，直到被执行完，如果较高优先级队列为空，这时就执行较低优先级队列中的进程
+ 这时如果有进程，插入较高优先级的队列，则停止当前运行的进程，插入到原队列的末尾，执行较高优先级的进程
+ 对于短作业，很可能在第一集队列被快速执行完，对于长作业会被移入下级队列等待执行
+ 虽然长作业等待的时间变长了，但是执行时间也变长了，该算法会有一个比较好的响应比

## 1.1​进程什么时候由用户态转化为内核态？
+ 用户态和内核态是操作系统的两种运行级别，用户态拥有较低的特权，内核态拥有较高的特权
+ 用户态和内核态转换的几种方式：系统调用，异常，中断，CPU的一些指令如果操作错误
+ 可能会导致系统崩溃，区分用户态后，当用户执行这些指令后，系统会提供API
+ 让其陷入内核态，让内核去执行这些指令,内核态可以访问任何资源，安全性要求高
+ 用户态访问资源受限，安全性要求低，系统调用是用户态主动要求转到内核态的一种方式
+ CPU在执行用户态的程序中，发现了异常，会触发内核态中异常处理的相关程序，切换到此处来处理
+ 当外设设备完成了用户请求后，会向CPU发出中断信号，CPU会暂停下一条要执行的指令
+ 转而执行中断信号要执行的程序
