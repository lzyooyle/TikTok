## 寄存器和程序计数器
+ 寄存器是CPU内部的速度极快的缓存
+ 程序计数器是用来记录正在执行的指令的位置，或者即将执行的下一条指令的位置

## CPU的上下文切换
+ 先将上一个任务的上下文保存起来，再加载新任务的上下文到寄存器和程序计数器
+ 然后跳转到程序计数器指定的新任务的位置，运行新任务
+ 当上个任务再次分配给CPU运行时，CPU会加载上次保存的上下文
+ 这样上个任务的状态不会受到影响，看起来任务没有被中断，是在连续运行
+ 任务包括了进程，线程，中断，所以CPU上下文切换包括了进程上下文切换，线程上下文切换，中断上下文切换
+ 进程是由内核调度和管理的，所以进程的切换，只能发生在内核态

## 进程上下文切换的场景
+ 进程的时间片用尽，状态会被改为就绪态，CPU会从就绪队列选择一个进程运行
+ 内存不足的时候，进程会被挂起，系统会调度其他的进程运行
+ 有高优先级的进程需要运行时，系统会挂起当前的低优先级进程

## 线程的上下文切换
+ 为什么不用多个进程，保证进程之间的数据通信是一件很复杂的事情
+ 进程的开销很大，涉及资源分配，建立PCD，资源回收，撤下PCD，进程切换保存状态信息
+ 线程之间可以共享相同的空间地址，可以并发执行
+ 线程是进程的一条执行流程，可以共享进程的资源，但各自具有独立的栈和寄存器
+ 进程是资源分配的单位，线程是CPU调度的单位，减少了进程并发执行的开销
+ 从空间角度来看，进程间的切换，需要CPU保存上一个任务的上下文，加载新任务的上下文
+ 通过程序计数器获取新任务的地址，指向新的位置，执行新任务
+ 线程是共享空间地址的，不需要使用程序计数器指向新的地址
+ 从时间角度来看，进程是内核调度管理的，进程切换只能发生在内核态
+ 不仅包含了进程的虚拟内存，栈，共享变量等，还需要切换内核态的堆栈，寄存器
+ 线程是共享进程资源的，只需要切换自己的栈和寄存器即可
+ 用户线程是在用户态实现的，是多对一的关系，内核线程是在内核态实现的，是一对一的关系
+ 轻量级线程是在内核中支持用户线程，是多对多的关系
+ 每个进程都要有一个线程控制块（CTB）列表，用来记录各个线程的状态（栈，寄存器）
+ TCB由用户线程库函数来维护，也负责线程的切换，无需内核态和用户态的切换

## 用户线程的缺点
+ 由于系统不参与用户线程的调用，所以当一个用户线程发生阻塞的时候，这个进程中所有用户线程都会阻塞
+ 当一个用户线程开始运行后，除非它自己主动交出CPU的控制权，否则该进程中的其他线程无法执行
+ 用户线程没有打断当前正在执行线程的特权，只有操作系统才有，用户线程又不归操作系统管理

## 调度算法
+ 非抢占式调度算法：操作系统从就绪队列中选一个进程执行，在该进程没有被阻塞或者结束之前
+ 不会选择其他进程执行，也就是说不会去理会时钟中断这个事情
+ 抢占式调度算法：调度程序挑选一个进程，让其在某段时间内运行，如果运行时间结束
+ 程序还没有执行完，则会将其挂起，然后从就绪队列中，挑选一个进程运行，这种算法也称为时间片机制

## 调度原则
+ CPU利用率要高，如果进程在执行过程中，发生IO事件，进程需要等待，CPU会出现空闲状态
+ 系统吞吐量要高（单位时间执行的进程数量），如果执行某个任务占用时间较长，会影响系统吞吐量
+ 周转时间（等待时间和运行时间），如果等待时间长，运行时间短，则周转时间长，不是我们希望的
+ 等待时间，等待时间不宜过长，这样可以让CPU更快的执行该程序
+ 响应时间，对于交互性比较强的应用，响应时间越短越好，可以提高用户体验
